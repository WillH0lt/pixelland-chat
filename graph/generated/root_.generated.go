// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/google/uuid"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
	"github.com/wwwillw/pixelland-chat/graph/model"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Channel() ChannelResolver
	Instance() InstanceResolver
	Invite() InviteResolver
	Message() MessageResolver
	Mutation() MutationResolver
	Notification() NotificationResolver
	Query() QueryResolver
	Subscription() SubscriptionResolver
	User() UserResolver
}

type DirectiveRoot struct {
	Auth       func(ctx context.Context, obj interface{}, next graphql.Resolver, accessLevel string) (res interface{}, err error)
	Constraint func(ctx context.Context, obj interface{}, next graphql.Resolver, min float64, max float64) (res interface{}, err error)
}

type ComplexityRoot struct {
	AppBadgesConnection struct {
		Edges    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	AppBadgesEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Author struct {
		Avatar     func(childComplexity int) int
		Bio        func(childComplexity int) int
		CreatedAt  func(childComplexity int) int
		ID         func(childComplexity int) int
		InstanceID func(childComplexity int) int
		Name       func(childComplexity int) int
		Roles      func(childComplexity int) int
		UserID     func(childComplexity int) int
	}

	Badge struct {
		ID   func(childComplexity int) int
		Icon func(childComplexity int) int
		Name func(childComplexity int) int
	}

	Channel struct {
		CreatedAt          func(childComplexity int) int
		ID                 func(childComplexity int) int
		InstanceID         func(childComplexity int) int
		IsCategory         func(childComplexity int) int
		IsComments         func(childComplexity int) int
		LastMessageAddedAt func(childComplexity int) int
		MessageCount       func(childComplexity int) int
		MessagesConnection func(childComplexity int, last int, before string) int
		Name               func(childComplexity int) int
		Publishers         func(childComplexity int) int
		Rank               func(childComplexity int) int
		Readers            func(childComplexity int) int
		UpdatedAt          func(childComplexity int) int
	}

	ChannelMessagesConnection struct {
		Edges    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	ChannelMessagesEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Instance struct {
		Author             func(childComplexity int) int
		AuthorsConnection  func(childComplexity int, roles []model.Role, first int, after string) int
		ChannelsConnection func(childComplexity int, first int, after string) int
		CommentsCount      func(childComplexity int) int
		CreatedAt          func(childComplexity int) int
		Description        func(childComplexity int) int
		ID                 func(childComplexity int) int
		Icon               func(childComplexity int) int
		LikesConnection    func(childComplexity int, first int, after string) int
		LikesCount         func(childComplexity int) int
		Name               func(childComplexity int) int
		ReadAccess         func(childComplexity int) int
		ShowAuthor         func(childComplexity int) int
		ShowChat           func(childComplexity int) int
		ShowComments       func(childComplexity int) int
		ShowLikes          func(childComplexity int) int
	}

	InstanceAuthorsConnection struct {
		Edges    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	InstanceAuthorsEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	InstanceChannelsConnection struct {
		Edges    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	InstanceChannelsEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	InstanceLikesConnection struct {
		Edges    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	InstanceLikesEdge struct {
		Cursor  func(childComplexity int) int
		LikedAt func(childComplexity int) int
		Node    func(childComplexity int) int
	}

	Invite struct {
		Author      func(childComplexity int) int
		Code        func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		ExpiresAt   func(childComplexity int) int
		ID          func(childComplexity int) int
		Instance    func(childComplexity int) int
		InstanceID  func(childComplexity int) int
		Redemptions func(childComplexity int) int
	}

	Message struct {
		Author    func(childComplexity int) int
		ChannelID func(childComplexity int) int
		CreatedAt func(childComplexity int) int
		ID        func(childComplexity int) int
		Text      func(childComplexity int) int
	}

	Mutation struct {
		AddBadge        func(childComplexity int, input model.BadgeInput) int
		AddChannel      func(childComplexity int, input model.ChannelInput) int
		AddInstance     func(childComplexity int, input model.InstanceInput) int
		AddInvite       func(childComplexity int, input model.InviteInput) int
		AddLike         func(childComplexity int, instanceID uuid.UUID) int
		AddMessage      func(childComplexity int, input model.MessageInput) int
		AddRole         func(childComplexity int, authorID uuid.UUID, role model.Role) int
		AssignBadge     func(childComplexity int, userID uuid.UUID, badgeID uuid.UUID) int
		PinInstance     func(childComplexity int, instanceID uuid.UUID, input model.InstancePinInput) int
		RedeemInvite    func(childComplexity int, code string) int
		RemoveBadge     func(childComplexity int, badgeID uuid.UUID) int
		RemoveChannel   func(childComplexity int, channelID uuid.UUID) int
		RemoveInstance  func(childComplexity int, instanceID uuid.UUID) int
		RemoveInvite    func(childComplexity int, inviteID uuid.UUID) int
		RemoveLike      func(childComplexity int, instanceID uuid.UUID) int
		RemoveMessage   func(childComplexity int, messageID uuid.UUID) int
		RemoveRole      func(childComplexity int, authorID uuid.UUID, role model.Role) int
		ReorderChannel  func(childComplexity int, channelID uuid.UUID, input model.ChannelReorderInput) int
		ReorderInstance func(childComplexity int, instanceID uuid.UUID, input model.InstanceReorderInput) int
		UnassignBadge   func(childComplexity int, userID uuid.UUID, badgeID uuid.UUID) int
		UpdateBadge     func(childComplexity int, badgeID uuid.UUID, input model.BadgeInput) int
		UpdateChannel   func(childComplexity int, channelID uuid.UUID, input model.ChannelInput) int
		UpdateInstance  func(childComplexity int, instanceID uuid.UUID, input model.InstanceInput) int
		UpdateUser      func(childComplexity int, input model.UserInput) int
	}

	Notice struct {
		Author                func(childComplexity int) int
		ChannelMessagesEdge   func(childComplexity int) int
		Instance              func(childComplexity int) int
		InstanceChannelsEdge  func(childComplexity int) int
		InstanceLikesEdge     func(childComplexity int) int
		Kind                  func(childComplexity int) int
		User                  func(childComplexity int) int
		UserInstancesEdge     func(childComplexity int) int
		UserNotificationsEdge func(childComplexity int) int
	}

	Notification struct {
		Author    func(childComplexity int) int
		CreatedAt func(childComplexity int) int
		ID        func(childComplexity int) int
		Instance  func(childComplexity int) int
		Kind      func(childComplexity int) int
		Message   func(childComplexity int) int
	}

	PageInfo struct {
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
	}

	Query struct {
		Author      func(childComplexity int, id uuid.UUID) int
		Badges      func(childComplexity int, first int, after string) int
		Channel     func(childComplexity int, id uuid.UUID) int
		CheckInvite func(childComplexity int, code string) int
		Instance    func(childComplexity int, id uuid.UUID) int
		Invite      func(childComplexity int, instanceID uuid.UUID) int
		User        func(childComplexity int) int
		UserBadges  func(childComplexity int, userID uuid.UUID, first int, after string) int
	}

	Subscription struct {
		Stream func(childComplexity int, instanceID uuid.UUID) int
	}

	User struct {
		Avatar                  func(childComplexity int) int
		Bio                     func(childComplexity int) int
		ID                      func(childComplexity int) int
		InstancesConnection     func(childComplexity int, first int, after string) int
		Name                    func(childComplexity int) int
		NotificationsConnection func(childComplexity int, last int, before string) int
		UID                     func(childComplexity int) int
	}

	UserBadgesConnection struct {
		Edges    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	UserBadgesEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	UserInstancesConnection struct {
		Edges    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	UserInstancesEdge struct {
		Cursor       func(childComplexity int) int
		InstanceUser func(childComplexity int) int
		LikedByMe    func(childComplexity int) int
		Node         func(childComplexity int) int
		Pinned       func(childComplexity int) int
		Rank         func(childComplexity int) int
	}

	UserNotificationsConnection struct {
		Edges     func(childComplexity int) int
		HasUnread func(childComplexity int) int
		PageInfo  func(childComplexity int) int
	}

	UserNotificationsEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "AppBadgesConnection.edges":
		if e.complexity.AppBadgesConnection.Edges == nil {
			break
		}

		return e.complexity.AppBadgesConnection.Edges(childComplexity), true

	case "AppBadgesConnection.pageInfo":
		if e.complexity.AppBadgesConnection.PageInfo == nil {
			break
		}

		return e.complexity.AppBadgesConnection.PageInfo(childComplexity), true

	case "AppBadgesEdge.cursor":
		if e.complexity.AppBadgesEdge.Cursor == nil {
			break
		}

		return e.complexity.AppBadgesEdge.Cursor(childComplexity), true

	case "AppBadgesEdge.node":
		if e.complexity.AppBadgesEdge.Node == nil {
			break
		}

		return e.complexity.AppBadgesEdge.Node(childComplexity), true

	case "Author.avatar":
		if e.complexity.Author.Avatar == nil {
			break
		}

		return e.complexity.Author.Avatar(childComplexity), true

	case "Author.bio":
		if e.complexity.Author.Bio == nil {
			break
		}

		return e.complexity.Author.Bio(childComplexity), true

	case "Author.createdAt":
		if e.complexity.Author.CreatedAt == nil {
			break
		}

		return e.complexity.Author.CreatedAt(childComplexity), true

	case "Author.id":
		if e.complexity.Author.ID == nil {
			break
		}

		return e.complexity.Author.ID(childComplexity), true

	case "Author.instanceId":
		if e.complexity.Author.InstanceID == nil {
			break
		}

		return e.complexity.Author.InstanceID(childComplexity), true

	case "Author.name":
		if e.complexity.Author.Name == nil {
			break
		}

		return e.complexity.Author.Name(childComplexity), true

	case "Author.roles":
		if e.complexity.Author.Roles == nil {
			break
		}

		return e.complexity.Author.Roles(childComplexity), true

	case "Author.userId":
		if e.complexity.Author.UserID == nil {
			break
		}

		return e.complexity.Author.UserID(childComplexity), true

	case "Badge.id":
		if e.complexity.Badge.ID == nil {
			break
		}

		return e.complexity.Badge.ID(childComplexity), true

	case "Badge.icon":
		if e.complexity.Badge.Icon == nil {
			break
		}

		return e.complexity.Badge.Icon(childComplexity), true

	case "Badge.name":
		if e.complexity.Badge.Name == nil {
			break
		}

		return e.complexity.Badge.Name(childComplexity), true

	case "Channel.createdAt":
		if e.complexity.Channel.CreatedAt == nil {
			break
		}

		return e.complexity.Channel.CreatedAt(childComplexity), true

	case "Channel.id":
		if e.complexity.Channel.ID == nil {
			break
		}

		return e.complexity.Channel.ID(childComplexity), true

	case "Channel.instanceId":
		if e.complexity.Channel.InstanceID == nil {
			break
		}

		return e.complexity.Channel.InstanceID(childComplexity), true

	case "Channel.isCategory":
		if e.complexity.Channel.IsCategory == nil {
			break
		}

		return e.complexity.Channel.IsCategory(childComplexity), true

	case "Channel.isComments":
		if e.complexity.Channel.IsComments == nil {
			break
		}

		return e.complexity.Channel.IsComments(childComplexity), true

	case "Channel.lastMessageAddedAt":
		if e.complexity.Channel.LastMessageAddedAt == nil {
			break
		}

		return e.complexity.Channel.LastMessageAddedAt(childComplexity), true

	case "Channel.messageCount":
		if e.complexity.Channel.MessageCount == nil {
			break
		}

		return e.complexity.Channel.MessageCount(childComplexity), true

	case "Channel.messagesConnection":
		if e.complexity.Channel.MessagesConnection == nil {
			break
		}

		args, err := ec.field_Channel_messagesConnection_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Channel.MessagesConnection(childComplexity, args["last"].(int), args["before"].(string)), true

	case "Channel.name":
		if e.complexity.Channel.Name == nil {
			break
		}

		return e.complexity.Channel.Name(childComplexity), true

	case "Channel.publishers":
		if e.complexity.Channel.Publishers == nil {
			break
		}

		return e.complexity.Channel.Publishers(childComplexity), true

	case "Channel.rank":
		if e.complexity.Channel.Rank == nil {
			break
		}

		return e.complexity.Channel.Rank(childComplexity), true

	case "Channel.readers":
		if e.complexity.Channel.Readers == nil {
			break
		}

		return e.complexity.Channel.Readers(childComplexity), true

	case "Channel.updatedAt":
		if e.complexity.Channel.UpdatedAt == nil {
			break
		}

		return e.complexity.Channel.UpdatedAt(childComplexity), true

	case "ChannelMessagesConnection.edges":
		if e.complexity.ChannelMessagesConnection.Edges == nil {
			break
		}

		return e.complexity.ChannelMessagesConnection.Edges(childComplexity), true

	case "ChannelMessagesConnection.pageInfo":
		if e.complexity.ChannelMessagesConnection.PageInfo == nil {
			break
		}

		return e.complexity.ChannelMessagesConnection.PageInfo(childComplexity), true

	case "ChannelMessagesEdge.cursor":
		if e.complexity.ChannelMessagesEdge.Cursor == nil {
			break
		}

		return e.complexity.ChannelMessagesEdge.Cursor(childComplexity), true

	case "ChannelMessagesEdge.node":
		if e.complexity.ChannelMessagesEdge.Node == nil {
			break
		}

		return e.complexity.ChannelMessagesEdge.Node(childComplexity), true

	case "Instance.author":
		if e.complexity.Instance.Author == nil {
			break
		}

		return e.complexity.Instance.Author(childComplexity), true

	case "Instance.authorsConnection":
		if e.complexity.Instance.AuthorsConnection == nil {
			break
		}

		args, err := ec.field_Instance_authorsConnection_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Instance.AuthorsConnection(childComplexity, args["roles"].([]model.Role), args["first"].(int), args["after"].(string)), true

	case "Instance.channelsConnection":
		if e.complexity.Instance.ChannelsConnection == nil {
			break
		}

		args, err := ec.field_Instance_channelsConnection_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Instance.ChannelsConnection(childComplexity, args["first"].(int), args["after"].(string)), true

	case "Instance.commentsCount":
		if e.complexity.Instance.CommentsCount == nil {
			break
		}

		return e.complexity.Instance.CommentsCount(childComplexity), true

	case "Instance.createdAt":
		if e.complexity.Instance.CreatedAt == nil {
			break
		}

		return e.complexity.Instance.CreatedAt(childComplexity), true

	case "Instance.description":
		if e.complexity.Instance.Description == nil {
			break
		}

		return e.complexity.Instance.Description(childComplexity), true

	case "Instance.id":
		if e.complexity.Instance.ID == nil {
			break
		}

		return e.complexity.Instance.ID(childComplexity), true

	case "Instance.icon":
		if e.complexity.Instance.Icon == nil {
			break
		}

		return e.complexity.Instance.Icon(childComplexity), true

	case "Instance.likesConnection":
		if e.complexity.Instance.LikesConnection == nil {
			break
		}

		args, err := ec.field_Instance_likesConnection_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Instance.LikesConnection(childComplexity, args["first"].(int), args["after"].(string)), true

	case "Instance.likesCount":
		if e.complexity.Instance.LikesCount == nil {
			break
		}

		return e.complexity.Instance.LikesCount(childComplexity), true

	case "Instance.name":
		if e.complexity.Instance.Name == nil {
			break
		}

		return e.complexity.Instance.Name(childComplexity), true

	case "Instance.readAccess":
		if e.complexity.Instance.ReadAccess == nil {
			break
		}

		return e.complexity.Instance.ReadAccess(childComplexity), true

	case "Instance.showAuthor":
		if e.complexity.Instance.ShowAuthor == nil {
			break
		}

		return e.complexity.Instance.ShowAuthor(childComplexity), true

	case "Instance.showChat":
		if e.complexity.Instance.ShowChat == nil {
			break
		}

		return e.complexity.Instance.ShowChat(childComplexity), true

	case "Instance.showComments":
		if e.complexity.Instance.ShowComments == nil {
			break
		}

		return e.complexity.Instance.ShowComments(childComplexity), true

	case "Instance.showLikes":
		if e.complexity.Instance.ShowLikes == nil {
			break
		}

		return e.complexity.Instance.ShowLikes(childComplexity), true

	case "InstanceAuthorsConnection.edges":
		if e.complexity.InstanceAuthorsConnection.Edges == nil {
			break
		}

		return e.complexity.InstanceAuthorsConnection.Edges(childComplexity), true

	case "InstanceAuthorsConnection.pageInfo":
		if e.complexity.InstanceAuthorsConnection.PageInfo == nil {
			break
		}

		return e.complexity.InstanceAuthorsConnection.PageInfo(childComplexity), true

	case "InstanceAuthorsEdge.cursor":
		if e.complexity.InstanceAuthorsEdge.Cursor == nil {
			break
		}

		return e.complexity.InstanceAuthorsEdge.Cursor(childComplexity), true

	case "InstanceAuthorsEdge.node":
		if e.complexity.InstanceAuthorsEdge.Node == nil {
			break
		}

		return e.complexity.InstanceAuthorsEdge.Node(childComplexity), true

	case "InstanceChannelsConnection.edges":
		if e.complexity.InstanceChannelsConnection.Edges == nil {
			break
		}

		return e.complexity.InstanceChannelsConnection.Edges(childComplexity), true

	case "InstanceChannelsConnection.pageInfo":
		if e.complexity.InstanceChannelsConnection.PageInfo == nil {
			break
		}

		return e.complexity.InstanceChannelsConnection.PageInfo(childComplexity), true

	case "InstanceChannelsEdge.cursor":
		if e.complexity.InstanceChannelsEdge.Cursor == nil {
			break
		}

		return e.complexity.InstanceChannelsEdge.Cursor(childComplexity), true

	case "InstanceChannelsEdge.node":
		if e.complexity.InstanceChannelsEdge.Node == nil {
			break
		}

		return e.complexity.InstanceChannelsEdge.Node(childComplexity), true

	case "InstanceLikesConnection.edges":
		if e.complexity.InstanceLikesConnection.Edges == nil {
			break
		}

		return e.complexity.InstanceLikesConnection.Edges(childComplexity), true

	case "InstanceLikesConnection.pageInfo":
		if e.complexity.InstanceLikesConnection.PageInfo == nil {
			break
		}

		return e.complexity.InstanceLikesConnection.PageInfo(childComplexity), true

	case "InstanceLikesEdge.cursor":
		if e.complexity.InstanceLikesEdge.Cursor == nil {
			break
		}

		return e.complexity.InstanceLikesEdge.Cursor(childComplexity), true

	case "InstanceLikesEdge.likedAt":
		if e.complexity.InstanceLikesEdge.LikedAt == nil {
			break
		}

		return e.complexity.InstanceLikesEdge.LikedAt(childComplexity), true

	case "InstanceLikesEdge.node":
		if e.complexity.InstanceLikesEdge.Node == nil {
			break
		}

		return e.complexity.InstanceLikesEdge.Node(childComplexity), true

	case "Invite.author":
		if e.complexity.Invite.Author == nil {
			break
		}

		return e.complexity.Invite.Author(childComplexity), true

	case "Invite.code":
		if e.complexity.Invite.Code == nil {
			break
		}

		return e.complexity.Invite.Code(childComplexity), true

	case "Invite.createdAt":
		if e.complexity.Invite.CreatedAt == nil {
			break
		}

		return e.complexity.Invite.CreatedAt(childComplexity), true

	case "Invite.expiresAt":
		if e.complexity.Invite.ExpiresAt == nil {
			break
		}

		return e.complexity.Invite.ExpiresAt(childComplexity), true

	case "Invite.id":
		if e.complexity.Invite.ID == nil {
			break
		}

		return e.complexity.Invite.ID(childComplexity), true

	case "Invite.instance":
		if e.complexity.Invite.Instance == nil {
			break
		}

		return e.complexity.Invite.Instance(childComplexity), true

	case "Invite.instanceId":
		if e.complexity.Invite.InstanceID == nil {
			break
		}

		return e.complexity.Invite.InstanceID(childComplexity), true

	case "Invite.redemptions":
		if e.complexity.Invite.Redemptions == nil {
			break
		}

		return e.complexity.Invite.Redemptions(childComplexity), true

	case "Message.author":
		if e.complexity.Message.Author == nil {
			break
		}

		return e.complexity.Message.Author(childComplexity), true

	case "Message.channelId":
		if e.complexity.Message.ChannelID == nil {
			break
		}

		return e.complexity.Message.ChannelID(childComplexity), true

	case "Message.createdAt":
		if e.complexity.Message.CreatedAt == nil {
			break
		}

		return e.complexity.Message.CreatedAt(childComplexity), true

	case "Message.id":
		if e.complexity.Message.ID == nil {
			break
		}

		return e.complexity.Message.ID(childComplexity), true

	case "Message.text":
		if e.complexity.Message.Text == nil {
			break
		}

		return e.complexity.Message.Text(childComplexity), true

	case "Mutation.addBadge":
		if e.complexity.Mutation.AddBadge == nil {
			break
		}

		args, err := ec.field_Mutation_addBadge_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddBadge(childComplexity, args["input"].(model.BadgeInput)), true

	case "Mutation.addChannel":
		if e.complexity.Mutation.AddChannel == nil {
			break
		}

		args, err := ec.field_Mutation_addChannel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddChannel(childComplexity, args["input"].(model.ChannelInput)), true

	case "Mutation.addInstance":
		if e.complexity.Mutation.AddInstance == nil {
			break
		}

		args, err := ec.field_Mutation_addInstance_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddInstance(childComplexity, args["input"].(model.InstanceInput)), true

	case "Mutation.addInvite":
		if e.complexity.Mutation.AddInvite == nil {
			break
		}

		args, err := ec.field_Mutation_addInvite_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddInvite(childComplexity, args["input"].(model.InviteInput)), true

	case "Mutation.addLike":
		if e.complexity.Mutation.AddLike == nil {
			break
		}

		args, err := ec.field_Mutation_addLike_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddLike(childComplexity, args["instanceId"].(uuid.UUID)), true

	case "Mutation.addMessage":
		if e.complexity.Mutation.AddMessage == nil {
			break
		}

		args, err := ec.field_Mutation_addMessage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddMessage(childComplexity, args["input"].(model.MessageInput)), true

	case "Mutation.addRole":
		if e.complexity.Mutation.AddRole == nil {
			break
		}

		args, err := ec.field_Mutation_addRole_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddRole(childComplexity, args["authorId"].(uuid.UUID), args["role"].(model.Role)), true

	case "Mutation.assignBadge":
		if e.complexity.Mutation.AssignBadge == nil {
			break
		}

		args, err := ec.field_Mutation_assignBadge_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AssignBadge(childComplexity, args["userId"].(uuid.UUID), args["badgeId"].(uuid.UUID)), true

	case "Mutation.pinInstance":
		if e.complexity.Mutation.PinInstance == nil {
			break
		}

		args, err := ec.field_Mutation_pinInstance_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PinInstance(childComplexity, args["instanceId"].(uuid.UUID), args["input"].(model.InstancePinInput)), true

	case "Mutation.redeemInvite":
		if e.complexity.Mutation.RedeemInvite == nil {
			break
		}

		args, err := ec.field_Mutation_redeemInvite_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RedeemInvite(childComplexity, args["code"].(string)), true

	case "Mutation.removeBadge":
		if e.complexity.Mutation.RemoveBadge == nil {
			break
		}

		args, err := ec.field_Mutation_removeBadge_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveBadge(childComplexity, args["badgeId"].(uuid.UUID)), true

	case "Mutation.removeChannel":
		if e.complexity.Mutation.RemoveChannel == nil {
			break
		}

		args, err := ec.field_Mutation_removeChannel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveChannel(childComplexity, args["channelId"].(uuid.UUID)), true

	case "Mutation.removeInstance":
		if e.complexity.Mutation.RemoveInstance == nil {
			break
		}

		args, err := ec.field_Mutation_removeInstance_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveInstance(childComplexity, args["instanceId"].(uuid.UUID)), true

	case "Mutation.removeInvite":
		if e.complexity.Mutation.RemoveInvite == nil {
			break
		}

		args, err := ec.field_Mutation_removeInvite_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveInvite(childComplexity, args["inviteId"].(uuid.UUID)), true

	case "Mutation.removeLike":
		if e.complexity.Mutation.RemoveLike == nil {
			break
		}

		args, err := ec.field_Mutation_removeLike_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveLike(childComplexity, args["instanceId"].(uuid.UUID)), true

	case "Mutation.removeMessage":
		if e.complexity.Mutation.RemoveMessage == nil {
			break
		}

		args, err := ec.field_Mutation_removeMessage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveMessage(childComplexity, args["messageId"].(uuid.UUID)), true

	case "Mutation.removeRole":
		if e.complexity.Mutation.RemoveRole == nil {
			break
		}

		args, err := ec.field_Mutation_removeRole_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveRole(childComplexity, args["authorId"].(uuid.UUID), args["role"].(model.Role)), true

	case "Mutation.reorderChannel":
		if e.complexity.Mutation.ReorderChannel == nil {
			break
		}

		args, err := ec.field_Mutation_reorderChannel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ReorderChannel(childComplexity, args["channelId"].(uuid.UUID), args["input"].(model.ChannelReorderInput)), true

	case "Mutation.reorderInstance":
		if e.complexity.Mutation.ReorderInstance == nil {
			break
		}

		args, err := ec.field_Mutation_reorderInstance_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ReorderInstance(childComplexity, args["instanceId"].(uuid.UUID), args["input"].(model.InstanceReorderInput)), true

	case "Mutation.unassignBadge":
		if e.complexity.Mutation.UnassignBadge == nil {
			break
		}

		args, err := ec.field_Mutation_unassignBadge_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UnassignBadge(childComplexity, args["userId"].(uuid.UUID), args["badgeId"].(uuid.UUID)), true

	case "Mutation.updateBadge":
		if e.complexity.Mutation.UpdateBadge == nil {
			break
		}

		args, err := ec.field_Mutation_updateBadge_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateBadge(childComplexity, args["badgeId"].(uuid.UUID), args["input"].(model.BadgeInput)), true

	case "Mutation.updateChannel":
		if e.complexity.Mutation.UpdateChannel == nil {
			break
		}

		args, err := ec.field_Mutation_updateChannel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateChannel(childComplexity, args["channelId"].(uuid.UUID), args["input"].(model.ChannelInput)), true

	case "Mutation.updateInstance":
		if e.complexity.Mutation.UpdateInstance == nil {
			break
		}

		args, err := ec.field_Mutation_updateInstance_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateInstance(childComplexity, args["instanceId"].(uuid.UUID), args["input"].(model.InstanceInput)), true

	case "Mutation.updateUser":
		if e.complexity.Mutation.UpdateUser == nil {
			break
		}

		args, err := ec.field_Mutation_updateUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUser(childComplexity, args["input"].(model.UserInput)), true

	case "Notice.author":
		if e.complexity.Notice.Author == nil {
			break
		}

		return e.complexity.Notice.Author(childComplexity), true

	case "Notice.channelMessagesEdge":
		if e.complexity.Notice.ChannelMessagesEdge == nil {
			break
		}

		return e.complexity.Notice.ChannelMessagesEdge(childComplexity), true

	case "Notice.instance":
		if e.complexity.Notice.Instance == nil {
			break
		}

		return e.complexity.Notice.Instance(childComplexity), true

	case "Notice.instanceChannelsEdge":
		if e.complexity.Notice.InstanceChannelsEdge == nil {
			break
		}

		return e.complexity.Notice.InstanceChannelsEdge(childComplexity), true

	case "Notice.instanceLikesEdge":
		if e.complexity.Notice.InstanceLikesEdge == nil {
			break
		}

		return e.complexity.Notice.InstanceLikesEdge(childComplexity), true

	case "Notice.kind":
		if e.complexity.Notice.Kind == nil {
			break
		}

		return e.complexity.Notice.Kind(childComplexity), true

	case "Notice.user":
		if e.complexity.Notice.User == nil {
			break
		}

		return e.complexity.Notice.User(childComplexity), true

	case "Notice.userInstancesEdge":
		if e.complexity.Notice.UserInstancesEdge == nil {
			break
		}

		return e.complexity.Notice.UserInstancesEdge(childComplexity), true

	case "Notice.userNotificationsEdge":
		if e.complexity.Notice.UserNotificationsEdge == nil {
			break
		}

		return e.complexity.Notice.UserNotificationsEdge(childComplexity), true

	case "Notification.author":
		if e.complexity.Notification.Author == nil {
			break
		}

		return e.complexity.Notification.Author(childComplexity), true

	case "Notification.createdAt":
		if e.complexity.Notification.CreatedAt == nil {
			break
		}

		return e.complexity.Notification.CreatedAt(childComplexity), true

	case "Notification.id":
		if e.complexity.Notification.ID == nil {
			break
		}

		return e.complexity.Notification.ID(childComplexity), true

	case "Notification.instance":
		if e.complexity.Notification.Instance == nil {
			break
		}

		return e.complexity.Notification.Instance(childComplexity), true

	case "Notification.kind":
		if e.complexity.Notification.Kind == nil {
			break
		}

		return e.complexity.Notification.Kind(childComplexity), true

	case "Notification.message":
		if e.complexity.Notification.Message == nil {
			break
		}

		return e.complexity.Notification.Message(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "Query.author":
		if e.complexity.Query.Author == nil {
			break
		}

		args, err := ec.field_Query_author_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Author(childComplexity, args["id"].(uuid.UUID)), true

	case "Query.badges":
		if e.complexity.Query.Badges == nil {
			break
		}

		args, err := ec.field_Query_badges_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Badges(childComplexity, args["first"].(int), args["after"].(string)), true

	case "Query.channel":
		if e.complexity.Query.Channel == nil {
			break
		}

		args, err := ec.field_Query_channel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Channel(childComplexity, args["id"].(uuid.UUID)), true

	case "Query.checkInvite":
		if e.complexity.Query.CheckInvite == nil {
			break
		}

		args, err := ec.field_Query_checkInvite_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CheckInvite(childComplexity, args["code"].(string)), true

	case "Query.instance":
		if e.complexity.Query.Instance == nil {
			break
		}

		args, err := ec.field_Query_instance_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Instance(childComplexity, args["id"].(uuid.UUID)), true

	case "Query.invite":
		if e.complexity.Query.Invite == nil {
			break
		}

		args, err := ec.field_Query_invite_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Invite(childComplexity, args["instanceId"].(uuid.UUID)), true

	case "Query.user":
		if e.complexity.Query.User == nil {
			break
		}

		return e.complexity.Query.User(childComplexity), true

	case "Query.userBadges":
		if e.complexity.Query.UserBadges == nil {
			break
		}

		args, err := ec.field_Query_userBadges_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserBadges(childComplexity, args["userId"].(uuid.UUID), args["first"].(int), args["after"].(string)), true

	case "Subscription.stream":
		if e.complexity.Subscription.Stream == nil {
			break
		}

		args, err := ec.field_Subscription_stream_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.Stream(childComplexity, args["instanceId"].(uuid.UUID)), true

	case "User.avatar":
		if e.complexity.User.Avatar == nil {
			break
		}

		return e.complexity.User.Avatar(childComplexity), true

	case "User.bio":
		if e.complexity.User.Bio == nil {
			break
		}

		return e.complexity.User.Bio(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.instancesConnection":
		if e.complexity.User.InstancesConnection == nil {
			break
		}

		args, err := ec.field_User_instancesConnection_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.InstancesConnection(childComplexity, args["first"].(int), args["after"].(string)), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.notificationsConnection":
		if e.complexity.User.NotificationsConnection == nil {
			break
		}

		args, err := ec.field_User_notificationsConnection_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.NotificationsConnection(childComplexity, args["last"].(int), args["before"].(string)), true

	case "User.uid":
		if e.complexity.User.UID == nil {
			break
		}

		return e.complexity.User.UID(childComplexity), true

	case "UserBadgesConnection.edges":
		if e.complexity.UserBadgesConnection.Edges == nil {
			break
		}

		return e.complexity.UserBadgesConnection.Edges(childComplexity), true

	case "UserBadgesConnection.pageInfo":
		if e.complexity.UserBadgesConnection.PageInfo == nil {
			break
		}

		return e.complexity.UserBadgesConnection.PageInfo(childComplexity), true

	case "UserBadgesEdge.cursor":
		if e.complexity.UserBadgesEdge.Cursor == nil {
			break
		}

		return e.complexity.UserBadgesEdge.Cursor(childComplexity), true

	case "UserBadgesEdge.node":
		if e.complexity.UserBadgesEdge.Node == nil {
			break
		}

		return e.complexity.UserBadgesEdge.Node(childComplexity), true

	case "UserInstancesConnection.edges":
		if e.complexity.UserInstancesConnection.Edges == nil {
			break
		}

		return e.complexity.UserInstancesConnection.Edges(childComplexity), true

	case "UserInstancesConnection.pageInfo":
		if e.complexity.UserInstancesConnection.PageInfo == nil {
			break
		}

		return e.complexity.UserInstancesConnection.PageInfo(childComplexity), true

	case "UserInstancesEdge.cursor":
		if e.complexity.UserInstancesEdge.Cursor == nil {
			break
		}

		return e.complexity.UserInstancesEdge.Cursor(childComplexity), true

	case "UserInstancesEdge.instanceUser":
		if e.complexity.UserInstancesEdge.InstanceUser == nil {
			break
		}

		return e.complexity.UserInstancesEdge.InstanceUser(childComplexity), true

	case "UserInstancesEdge.likedByMe":
		if e.complexity.UserInstancesEdge.LikedByMe == nil {
			break
		}

		return e.complexity.UserInstancesEdge.LikedByMe(childComplexity), true

	case "UserInstancesEdge.node":
		if e.complexity.UserInstancesEdge.Node == nil {
			break
		}

		return e.complexity.UserInstancesEdge.Node(childComplexity), true

	case "UserInstancesEdge.pinned":
		if e.complexity.UserInstancesEdge.Pinned == nil {
			break
		}

		return e.complexity.UserInstancesEdge.Pinned(childComplexity), true

	case "UserInstancesEdge.rank":
		if e.complexity.UserInstancesEdge.Rank == nil {
			break
		}

		return e.complexity.UserInstancesEdge.Rank(childComplexity), true

	case "UserNotificationsConnection.edges":
		if e.complexity.UserNotificationsConnection.Edges == nil {
			break
		}

		return e.complexity.UserNotificationsConnection.Edges(childComplexity), true

	case "UserNotificationsConnection.hasUnread":
		if e.complexity.UserNotificationsConnection.HasUnread == nil {
			break
		}

		return e.complexity.UserNotificationsConnection.HasUnread(childComplexity), true

	case "UserNotificationsConnection.pageInfo":
		if e.complexity.UserNotificationsConnection.PageInfo == nil {
			break
		}

		return e.complexity.UserNotificationsConnection.PageInfo(childComplexity), true

	case "UserNotificationsEdge.cursor":
		if e.complexity.UserNotificationsEdge.Cursor == nil {
			break
		}

		return e.complexity.UserNotificationsEdge.Cursor(childComplexity), true

	case "UserNotificationsEdge.node":
		if e.complexity.UserNotificationsEdge.Node == nil {
			break
		}

		return e.complexity.UserNotificationsEdge.Node(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputBadgeInput,
		ec.unmarshalInputChannelInput,
		ec.unmarshalInputChannelReorderInput,
		ec.unmarshalInputInstanceInput,
		ec.unmarshalInputInstancePinInput,
		ec.unmarshalInputInstanceReorderInput,
		ec.unmarshalInputInviteInput,
		ec.unmarshalInputMessageInput,
		ec.unmarshalInputUserInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Subscription:
		next := ec._Subscription(ctx, rc.Operation.SelectionSet)

		var buf bytes.Buffer
		return func(ctx context.Context) *graphql.Response {
			buf.Reset()
			data := next(ctx)

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema.graphqls", Input: `# ==============================================
# base types
type User {
  id: Uuid!
  uid: String!
  name: String!
  avatar: String!
  bio: String!
  instancesConnection(
    first: Int! = 0 @constraint(max: 50)
    after: String! = ""
  ): UserInstancesConnection!
  notificationsConnection(
    last: Int! = 0 @constraint(max: 50)
    before: String! = ""
  ): UserNotificationsConnection!
}

type Instance {
  id: Uuid!
  name: String!
  author: Author!
  readAccess: Access!
  icon: String!
  createdAt: Time!
  description: String!
  showAuthor: Boolean!
  showChat: Boolean!
  showComments: Boolean!
  showLikes: Boolean!
  likesCount: Int!
  commentsCount: Int!
  channelsConnection(
    first: Int! = 0 @constraint(max: 50)
    after: String! = ""
  ): InstanceChannelsConnection!
  likesConnection(
    first: Int! = 0 @constraint(max: 50)
    after: String! = ""
  ): InstanceLikesConnection!
  authorsConnection(
    roles: [Role!]!
    first: Int! = 0 @constraint(max: 50)
    after: String! = ""
  ): InstanceAuthorsConnection!
}

type Invite {
  id: Uuid!
  instanceId: Uuid!
  instance: Instance
  author: Author!
  code: String!
  createdAt: Time!
  expiresAt: Time
  redemptions: Int
}

type Channel {
  id: Uuid!
  rank: String!
  name: String!
  createdAt: Time!
  instanceId: Uuid!
  updatedAt: Time!
  lastMessageAddedAt: Time
  isCategory: Boolean!
  isComments: Boolean!
  messageCount: Int!
  messagesConnection(
    last: Int! = 0 @constraint(max: 50)
    before: String! = ""
  ): ChannelMessagesConnection!
  publishers: [Role!]!
  readers: [Role!]!
}

type Message {
  id: Uuid!
  text: String!
  author: Author!
  createdAt: Time!
  channelId: Uuid!
}

type Badge {
  id: Uuid!
  name: String!
  icon: String!
}

type Author {
  id: Uuid!
  userId: Uuid!
  instanceId: Uuid!
  roles: [Role!]!
  name: String!
  avatar: String!
  bio: String!
  createdAt: Time!
}

type Notification {
  id: Uuid!
  createdAt: Time!
  kind: NotificationKind!
  author: Author!
  instance: Instance
  message: Message
}

# ==============================================
# connections
type UserInstancesConnection {
  pageInfo: PageInfo!
  edges: [UserInstancesEdge!]!
}

type UserNotificationsConnection {
  pageInfo: PageInfo!
  edges: [UserNotificationsEdge!]!
  hasUnread: Boolean!
  # lastSeenAt: Time
}

type InstanceChannelsConnection {
  pageInfo: PageInfo!
  edges: [InstanceChannelsEdge!]!
}

type InstanceLikesConnection {
  pageInfo: PageInfo!
  edges: [InstanceLikesEdge!]!
}

type InstanceAuthorsConnection {
  pageInfo: PageInfo!
  edges: [InstanceAuthorsEdge!]!
}

type ChannelMessagesConnection {
  pageInfo: PageInfo!
  edges: [ChannelMessagesEdge!]!
}

type UserBadgesConnection {
  pageInfo: PageInfo!
  edges: [UserBadgesEdge!]!
}

type AppBadgesConnection {
  pageInfo: PageInfo!
  edges: [AppBadgesEdge!]!
}

# ==============================================
# edges
type UserInstancesEdge {
  cursor: String!
  node: Instance!
  instanceUser: Author!
  likedByMe: Boolean!
  rank: String!
  pinned: Boolean!
}

type UserNotificationsEdge {
  cursor: String!
  node: Notification!
}

type InstanceChannelsEdge {
  cursor: String!
  node: Channel!
}

type InstanceLikesEdge {
  cursor: String!
  likedAt: Time!
  node: Author!
}

type InstanceAuthorsEdge {
  cursor: String!
  node: Author!
}

type ChannelMessagesEdge {
  cursor: String!
  node: Message!
}

type UserBadgesEdge {
  cursor: String!
  node: Badge!
}

type AppBadgesEdge {
  cursor: String!
  node: Badge!
}

# ==============================================
# streams
type Notice {
  kind: NoticeKind!
  channelMessagesEdge: ChannelMessagesEdge
  userInstancesEdge: UserInstancesEdge
  instanceChannelsEdge: InstanceChannelsEdge
  instanceLikesEdge: InstanceLikesEdge
  userNotificationsEdge: UserNotificationsEdge
  instance: Instance
  user: User
  author: Author
}

# ==============================================
# misc
type PageInfo {
  hasPreviousPage: Boolean!
  hasNextPage: Boolean!
}

# ==============================================
# API
type Query {
  user: User! @auth(accessLevel: "user")
  instance(id: Uuid!): UserInstancesEdge! @auth(accessLevel: "guest")
  channel(id: Uuid!): Channel! @auth(accessLevel: "guest")
  invite(instanceId: Uuid!): Invite! @auth(accessLevel: "guest")
  checkInvite(code: String!): Invite! @auth(accessLevel: "guest")
  author(id: Uuid!): Author! @auth(accessLevel: "guest")
  userBadges(
    userId: Uuid!
    first: Int! = 0 @constraint(max: 50)
    after: String! = ""
  ): UserBadgesConnection! @auth(accessLevel: "guest")
  badges(first: Int! = 0 @constraint(max: 50), after: String! = ""): AppBadgesConnection!
    @auth(accessLevel: "admin")
}

type Mutation {
  # user
  updateUser(input: UserInput!): User! @auth(accessLevel: "user")
  # instance
  addInstance(input: InstanceInput!): UserInstancesEdge! @auth(accessLevel: "user")
  updateInstance(instanceId: Uuid!, input: InstanceInput!): UserInstancesEdge!
    @auth(accessLevel: "user")
  removeInstance(instanceId: Uuid!): UserInstancesEdge! @auth(accessLevel: "user")
  reorderInstance(instanceId: Uuid!, input: InstanceReorderInput!): UserInstancesEdge!
    @auth(accessLevel: "user")
  pinInstance(instanceId: Uuid!, input: InstancePinInput!): UserInstancesEdge!
    @auth(accessLevel: "user")
  # channel
  addChannel(input: ChannelInput!): InstanceChannelsEdge! @auth(accessLevel: "user")
  updateChannel(channelId: Uuid!, input: ChannelInput!): InstanceChannelsEdge!
    @auth(accessLevel: "user")
  reorderChannel(channelId: Uuid!, input: ChannelReorderInput!): InstanceChannelsEdge!
    @auth(accessLevel: "user")
  removeChannel(channelId: Uuid!): InstanceChannelsEdge! @auth(accessLevel: "user")
  # message
  addMessage(input: MessageInput!): ChannelMessagesEdge! @auth(accessLevel: "user")
  removeMessage(messageId: Uuid!): ChannelMessagesEdge! @auth(accessLevel: "user")
  # author
  addRole(authorId: Uuid!, role: Role!): Author! @auth(accessLevel: "user")
  removeRole(authorId: Uuid!, role: Role!): Author! @auth(accessLevel: "user")
  # invite
  addInvite(input: InviteInput!): Invite! @auth(accessLevel: "user")
  removeInvite(inviteId: Uuid!): Invite! @auth(accessLevel: "user")
  redeemInvite(code: String!): Invite! @auth(accessLevel: "user")
  # like
  addLike(instanceId: Uuid!): InstanceLikesEdge! @auth(accessLevel: "user")
  removeLike(instanceId: Uuid!): InstanceLikesEdge! @auth(accessLevel: "user")
  # badge
  addBadge(input: BadgeInput!): Badge! @auth(accessLevel: "admin")
  assignBadge(userId: Uuid!, badgeId: Uuid!): Badge! @auth(accessLevel: "admin")
  unassignBadge(userId: Uuid!, badgeId: Uuid!): Badge! @auth(accessLevel: "admin")
  updateBadge(badgeId: Uuid!, input: BadgeInput!): Badge! @auth(accessLevel: "admin")
  removeBadge(badgeId: Uuid!): Badge! @auth(accessLevel: "admin")
}

type Subscription {
  stream(instanceId: Uuid!): Notice! @auth(accessLevel: "guest")
}

# ==============================================
# input
input InstanceInput {
  id: Uuid # used to create instance with custom ID
  name: String! @constraint(min: 0, max: 32)
  readAccess: Access!
  icon: String! @constraint(min: 0, max: 1024)
  description: String! @constraint(min: 0, max: 1024)
  showAuthor: Boolean!
  showChat: Boolean!
  showComments: Boolean!
  showLikes: Boolean!
}

input InstanceReorderInput {
  prevInstanceId: Uuid
}

input InstancePinInput {
  pinned: Boolean!
}

input ChannelInput {
  name: String! @constraint(min: 0, max: 32)
  instanceId: Uuid!
  publishers: [Role!]!
  readers: [Role!]!
  isCategory: Boolean!
}

input ChannelReorderInput {
  prevChannelId: Uuid
}

input MessageInput {
  text: String! @constraint(min: 1, max: 1024)
  channelId: Uuid!
}

input UserInput {
  name: String! @constraint(min: 0, max: 32)
  avatar: String!
  bio: String! @constraint(min: 0, max: 1024)
}

input InviteInput {
  instanceId: Uuid!
  expiresAt: Time
  redemptions: Int
}

input BadgeInput {
  name: String! @constraint(min: 0, max: 64)
  icon: String! @constraint(min: 0, max: 1024)
}

# ==============================================
# enum
enum Access {
  PUBLIC
  PRIVATE
}

enum Role {
  ADMIN
  MODERATOR
  MEMBER
  BANNED
  ALL_USERS
}

enum NoticeKind {
  MESSAGE_ADDED
  MESSAGE_REMOVED
  CHANNEL_ADDED
  CHANNEL_UPDATED
  CHANNEL_REMOVED
  AUTHOR_UPDATED
  USER_UPDATED # TODO, this gets broadcast to everybody, need to limit to instanceUser update
  INSTANCE_UPDATED
  INSTANCE_REMOVED
  LIKE_ADDED
  LIKE_REMOVED
  NOTIFICATION_ADDED
}

enum NotificationKind {
  LIKE_ADDED
  COMMENT_ADDED
}

# ==============================================
# scalars
scalar Time
scalar Uuid

# ==============================================
# directives
directive @constraint(
  min: Float! = 0
  max: Float! = 50
) on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @auth(accessLevel: String!) on FIELD_DEFINITION
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
