package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.40

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/jinzhu/copier"
	"github.com/lib/pq"
	"github.com/rs/zerolog/log"
	"github.com/wwwillw/pixelland-chat/graph/generated"
	"github.com/wwwillw/pixelland-chat/graph/model"
	"github.com/wwwillw/pixelland-chat/interfaces"
	"github.com/wwwillw/pixelland-chat/pixellandchat"
	"github.com/xissy/lexorank"
	"gorm.io/gorm"
)

// MessagesConnection is the resolver for the messagesConnection field.
func (r *channelResolver) MessagesConnection(ctx context.Context, obj *model.Channel, last int, before string) (*model.ChannelMessagesConnection, error) {
	if last == 0 {
		return &model.ChannelMessagesConnection{
			Edges: make([]*model.ChannelMessagesEdge, 0),
			PageInfo: &model.PageInfo{
				HasNextPage:     false,
				HasPreviousPage: false,
			},
		}, nil
	}

	db := interfaces.GetDatabase()
	messages := []model.Message{}

	tx := db.Model(&obj).Limit(last + 1).Order("created_at desc").Where("deleted_at is NULL")

	if before != "" {
		createdAt, err := fromCursorHash(before)
		if err != nil {
			return nil, err
		}
		tx = tx.Where("created_at < ?", createdAt)
	}

	tx.Preload("Author").Association("Messages").Find(&messages)

	hasPreviousPage := (len(messages) == last+1)
	if len(messages) > 0 && hasPreviousPage {
		messages = messages[:len(messages)-1]
	}

	edges := []*model.ChannelMessagesEdge{}
	for i := len(messages) - 1; i >= 0; i-- {
		edge := createChannelMessagesEdge(&messages[i])
		edges = append(edges, edge)
	}

	return &model.ChannelMessagesConnection{
		Edges: edges,
		PageInfo: &model.PageInfo{
			HasPreviousPage: hasPreviousPage,
			HasNextPage:     false, // TODO
		},
	}, nil
}

// Publishers is the resolver for the publishers field.
func (r *channelResolver) Publishers(ctx context.Context, obj *model.Channel) ([]model.Role, error) {
	return stringsToRoles(obj.Publishers), nil
}

// Readers is the resolver for the readers field.
func (r *channelResolver) Readers(ctx context.Context, obj *model.Channel) ([]model.Role, error) {
	return stringsToRoles(obj.Readers), nil
}

// Author is the resolver for the author field.
func (r *instanceResolver) Author(ctx context.Context, obj *model.Instance) (*model.Author, error) {
	instanceUser := model.InstanceUser{}
	if obj.Author == nil {
		db := interfaces.GetDatabase()
		if err := db.First(&instanceUser, obj.AuthorID).Error; err != nil {
			return nil, err
		}
	} else {
		instanceUser = *obj.Author
	}

	return instanceUserToAuthor(&instanceUser), nil
}

// ReadAccess is the resolver for the readAccess field.
func (r *instanceResolver) ReadAccess(ctx context.Context, obj *model.Instance) (model.Access, error) {
	return model.Access(obj.ReadAccess), nil
}

// ChannelsConnection is the resolver for the channelsConnection field.
func (r *instanceResolver) ChannelsConnection(ctx context.Context, obj *model.Instance, first int, after string) (*model.InstanceChannelsConnection, error) {
	if first == 0 {
		return &model.InstanceChannelsConnection{
			Edges: make([]*model.InstanceChannelsEdge, 0),
			PageInfo: &model.PageInfo{
				HasNextPage:     false,
				HasPreviousPage: false,
			},
		}, nil
	}

	callerInstanceUser, err := getCallerInstanceUser(ctx, obj.ID)
	if err != nil {
		return nil, err
	}

	if contains(callerInstanceUser.Roles, model.RoleBanned.String()) || (obj.ReadAccess == model.AccessPrivate.String() && len(callerInstanceUser.Roles) == 0) {
		return &model.InstanceChannelsConnection{
			Edges: make([]*model.InstanceChannelsEdge, 0),
			PageInfo: &model.PageInfo{
				HasNextPage:     false,
				HasPreviousPage: false,
			},
		}, nil
	}

	db := interfaces.GetDatabase()
	channels := []model.Channel{}

	tx := db.Model(&obj).Limit(first + 1).Order("rank asc")

	roles := append(callerInstanceUser.Roles, model.RoleAllUsers.String())
	tx = tx.Where("deleted_at is NULL").Where("readers && ?", pq.Array(roles))

	if after != "" {
		rank, err := fromCursorHash(after)
		if err != nil {
			return nil, err
		}
		tx = tx.Where("rank > ?", rank)
	}

	if err := tx.Association("Channels").Find(&channels); err != nil {
		return nil, err
	}

	hasNextPage := (len(channels) == first+1)
	if len(channels) > 0 && hasNextPage {
		channels = channels[:len(channels)-1]
	}

	edges := []*model.InstanceChannelsEdge{}
	for i := 0; i < len(channels); i++ {
		edge := createInstanceChannelsEdge(&channels[i])
		edges = append(edges, edge)
	}

	return &model.InstanceChannelsConnection{
		Edges: edges,
		PageInfo: &model.PageInfo{
			HasNextPage:     hasNextPage,
			HasPreviousPage: false, // TODO
		},
	}, nil
}

// LikesConnection is the resolver for the likesConnection field.
func (r *instanceResolver) LikesConnection(ctx context.Context, obj *model.Instance, first int, after string) (*model.InstanceLikesConnection, error) {
	if first == 0 {
		return &model.InstanceLikesConnection{
			Edges: make([]*model.InstanceLikesEdge, 0),
			PageInfo: &model.PageInfo{
				HasNextPage:     false,
				HasPreviousPage: false,
			},
		}, nil
	}

	db := interfaces.GetDatabase()
	instanceUsers := []model.InstanceUser{}

	tx := db.Model(&obj).Limit(first + 1).Order("created_at asc")
	tx = tx.Where("liked_by_me = ?", true)

	if after != "" {
		likedAt, err := fromCursorHash(after)
		if err != nil {
			return nil, err
		}
		tx = tx.Where("liked_at > ?", likedAt)
	}

	if err := tx.Association("Users").Find(&instanceUsers); err != nil {
		return nil, err
	}

	hasNextPage := (len(instanceUsers) == first+1)
	if len(instanceUsers) > 0 && hasNextPage {
		instanceUsers = instanceUsers[:len(instanceUsers)-1]
	}

	edges := []*model.InstanceLikesEdge{}
	for i := 0; i < len(instanceUsers); i++ {
		edge := createInstanceLikesEdge(&instanceUsers[i])
		edges = append(edges, edge)
	}

	return &model.InstanceLikesConnection{
		Edges: edges,
		PageInfo: &model.PageInfo{
			HasNextPage:     hasNextPage,
			HasPreviousPage: false, // TODO
		},
	}, nil
}

// AuthorsConnection is the resolver for the authorsConnection field.
func (r *instanceResolver) AuthorsConnection(ctx context.Context, obj *model.Instance, roles []model.Role, first int, after string) (*model.InstanceAuthorsConnection, error) {
	if first == 0 || len(roles) == 0 {
		return &model.InstanceAuthorsConnection{
			Edges: make([]*model.InstanceAuthorsEdge, 0),
			PageInfo: &model.PageInfo{
				HasNextPage:     false,
				HasPreviousPage: false,
			},
		}, nil
	}

	db := interfaces.GetDatabase()
	instanceUsers := []model.InstanceUser{}

	tx := db.Model(&obj).Limit(first + 1).Order("created_at desc")
	tx = tx.Where("roles && ?", pq.Array(roles))

	// hide banned users
	if !contains(rolesToStrings(roles), model.RoleBanned.String()) {
		tx = tx.Where("Not(roles @> ?)", pq.Array([]string{model.RoleBanned.String()}))
	}

	if after != "" {
		created_at, err := fromCursorHash(after)
		if err != nil {
			return nil, err
		}
		tx = tx.Where("created_at < ?", created_at)
	}

	tx = tx.Where("deleted_at is NULL")

	if err := tx.Association("Users").Find(&instanceUsers); err != nil {
		return nil, err
	}

	hasNextPage := (len(instanceUsers) == first+1)
	if len(instanceUsers) > 0 && hasNextPage {
		instanceUsers = instanceUsers[:len(instanceUsers)-1]
	}

	edges := []*model.InstanceAuthorsEdge{}
	for i := 0; i < len(instanceUsers); i++ {
		edge := createInstanceAuthorsEdge(&instanceUsers[i])
		edges = append(edges, edge)
	}

	return &model.InstanceAuthorsConnection{
		Edges: edges,
		PageInfo: &model.PageInfo{
			HasNextPage:     hasNextPage,
			HasPreviousPage: false, // TODO
		},
	}, nil
}

// Author is the resolver for the author field.
func (r *inviteResolver) Author(ctx context.Context, obj *model.Invite) (*model.Author, error) {
	instanceUser := model.InstanceUser{}
	if obj.Author == nil {
		db := interfaces.GetDatabase()
		if err := db.First(&instanceUser, obj.AuthorID).Error; err != nil {
			return nil, err
		}
	} else {
		instanceUser = *obj.Author
	}

	return instanceUserToAuthor(&instanceUser), nil
}

// Author is the resolver for the author field.
func (r *messageResolver) Author(ctx context.Context, obj *model.Message) (*model.Author, error) {
	instanceUser := model.InstanceUser{}
	if obj.Author == nil {
		db := interfaces.GetDatabase()
		if err := db.First(&instanceUser, obj.AuthorID).Error; err != nil {
			return nil, err
		}
	} else {
		instanceUser = *obj.Author
	}

	return instanceUserToAuthor(&instanceUser), nil
}

// RepliedMessage is the resolver for the repliedMessage field.
func (r *messageResolver) RepliedMessage(ctx context.Context, obj *model.Message) (*model.Message, error) {
	if obj.RepliedMessageID == nil {
		return nil, nil
	}

	db := interfaces.GetDatabase()
	message := model.Message{}
	if err := db.First(&message, obj.RepliedMessageID).Error; err != nil {
		return nil, nil
	}

	return &message, nil
}

// ImageUrls is the resolver for the imageUrls field.
func (r *messageResolver) ImageUrls(ctx context.Context, obj *model.Message) ([]string, error) {
	return obj.ImageUrls, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input model.UserInput) (*model.User, error) {
	caller, err := upsertCaller(ctx)
	if err != nil {
		return nil, err
	}

	changed := caller.Name != input.Name || caller.Avatar != input.Avatar || caller.Bio != input.Bio

	if changed {

		caller.Name = input.Name
		caller.Avatar = input.Avatar
		caller.Bio = input.Bio

		log.Info().Msgf("UpdateUser: %+v", caller)

		db := interfaces.GetDatabase()
		if err := db.Save(&caller).Error; err != nil {
			return nil, err
		}

		if err := db.Model(model.InstanceUser{}).Where("user_id = ?", caller.ID).Updates(model.InstanceUser{
			Name:   caller.Name,
			Avatar: caller.Avatar,
			Bio:    caller.Bio,
		}).Error; err != nil {
			return nil, err
		}

		sendInstanceUserNotice(&r.StreamObservers, caller, model.NoticeKindUserUpdated)

		client := interfaces.GetPubSubClient()
		userFragment := pixellandchat.UserFragment{}
		copier.Copy(&userFragment, caller)
		client.PublishUserEvent(ctx, model.NoticeKindUserUpdated, userFragment)
	}

	return caller, nil
}

// AddInstance is the resolver for the addInstance field.
func (r *mutationResolver) AddInstance(ctx context.Context, input model.InstanceInput) (*model.UserInstancesEdge, error) {
	db := interfaces.GetDatabase()

	instance := model.Instance{}
	populateInstanceFromInput(&instance, input)

	if err := db.Create(&instance).Error; err != nil {
		return nil, err
	}

	caller, err := upsertCaller(ctx)
	if err != nil {
		return nil, err
	}

	roles := []string{
		model.RoleAdmin.String(),
		model.RoleModerator.String(),
		model.RoleMember.String(),
	}
	instanceUser := userToInstanceUser(caller, instance, roles)

	// set the new channels rank
	var rank string
	// TODO use COLLATE "C"
	row := db.Table("instance_users").Where("user_id = ? AND deleted_at is NULL", caller.ID).Select("coalesce(max(rank), '0')").Row()
	if err := row.Scan(&rank); err != nil {
		if err != sql.ErrNoRows {
			rank = "0"
		} else {
			log.Info().Err(err).Msg("failed to get instance rank")
			return nil, err
		}
	}
	if newRank, ok := lexorank.Rank(rank, ""); ok {
		instanceUser.Rank = newRank
	} else {
		return nil, errors.New("failed to get instance rank")
	}

	if err := db.Save(&instanceUser).Error; err != nil {
		return nil, err
	}

	instance.Author = instanceUser
	instance.AuthorID = instanceUser.ID
	if err := db.Save(&instance).Error; err != nil {
		return nil, err
	}

	// create comments channel
	commentsChannel := model.Channel{}
	commentsChannel.AuthorID = instanceUser.ID
	commentsChannel.Author = instanceUser
	commentsChannel.IsComments = true
	commentsChannel.Rank = "a"
	commentsChannelInput := model.ChannelInput{
		Name:       "Comments",
		InstanceID: instance.ID,
		Publishers: []model.Role{
			model.RoleAllUsers,
		},
		Readers: []model.Role{
			model.RoleAllUsers,
		},
	}
	if err := populateChannelFromInput(&commentsChannel, commentsChannelInput); err != nil {
		return nil, err
	}
	if err := db.Create(&commentsChannel).Error; err != nil {
		return nil, err
	}

	edge := createUserInstancesEdge(instanceUser, &instance)
	return edge, nil
}

// UpdateInstance is the resolver for the updateInstance field.
func (r *mutationResolver) UpdateInstance(ctx context.Context, instanceID uuid.UUID, input model.InstanceInput) (*model.UserInstancesEdge, error) {
	callerInstanceUser, err := getCallerInstanceUser(ctx, instanceID)
	if err != nil {
		return nil, err
	}

	if err := assertIsAdmin(*callerInstanceUser); err != nil {
		return nil, err
	}

	if input.ID != nil && *input.ID != instanceID {
		return nil, errors.New("cannot change instance id")
	}

	db := interfaces.GetDatabase()

	instance := model.Instance{}
	if err := db.First(&instance, instanceID).Error; err != nil {
		return nil, err
	}

	populateInstanceFromInput(&instance, input)

	if err := db.Save(&instance).Error; err != nil {
		return nil, err
	}

	sendInstanceNotice(&r.StreamObservers, &instance, model.NoticeKindInstanceUpdated)

	client := interfaces.GetPubSubClient()
	instanceFragment := pixellandchat.InstanceFragment{}
	copier.Copy(&instanceFragment, instance)
	client.PublishInstanceEvent(ctx, model.NoticeKindInstanceUpdated, instanceFragment)

	edge := createUserInstancesEdge(callerInstanceUser, &instance)
	return edge, nil
}

// RemoveInstance is the resolver for the removeInstance field.
func (r *mutationResolver) RemoveInstance(ctx context.Context, instanceID uuid.UUID) (*model.UserInstancesEdge, error) {
	callerInstanceUser, err := getCallerInstanceUser(ctx, instanceID)
	if err != nil {
		return nil, err
	}

	if err := assertIsAdmin(*callerInstanceUser); err != nil {
		return nil, err
	}

	db := interfaces.GetDatabase()

	instance := model.Instance{}

	if err := db.Preload("Author").First(&instance, instanceID).Error; err != nil {
		return nil, err
	}

	if err := db.Delete(&instance, instance).Error; err != nil {
		return nil, err
	}

	if err := db.Delete(&model.InstanceUser{}, "instance_id = ?", instanceID).Error; err != nil {
		return nil, err
	}

	if err := db.Delete(&model.Invite{}, "instance_id = ?", instanceID).Error; err != nil {
		return nil, err
	}

	if err := db.Delete(&model.Notification{}, "instance_id = ?", instanceID).Error; err != nil {
		return nil, err
	}

	sendInstanceNotice(&r.StreamObservers, &instance, model.NoticeKindInstanceRemoved)

	edge := createUserInstancesEdge(callerInstanceUser, &instance)
	return edge, nil
}

// ReorderInstance is the resolver for the reorderInstance field.
func (r *mutationResolver) ReorderInstance(ctx context.Context, instanceID uuid.UUID, input model.InstanceReorderInput) (*model.UserInstancesEdge, error) {
	caller, err := upsertCaller(ctx)
	if err != nil {
		return nil, err
	}

	db := interfaces.GetDatabase()
	instanceUser := model.InstanceUser{}
	instanceUser.InstanceID = instanceID
	instanceUser.UserID = caller.ID
	if err := db.Preload("Instance").First(&instanceUser, instanceUser).Error; err != nil {
		return nil, err
	}

	instanceUser.Pinned = true

	prevInstance := model.InstanceUser{}
	if input.PrevInstanceID != nil {
		prevInstance.InstanceID = *input.PrevInstanceID
		prevInstance.UserID = caller.ID
		if err := db.First(&prevInstance, prevInstance).Error; err != nil {
			return nil, err
		}
	}

	// update the instance's rank
	var nextRank string
	row := db.Raw(`
		SELECT rank FROM instance_users
		WHERE user_id = ? AND deleted_at is NULL AND pinned = ? AND rank > ? COLLATE "C"
		ORDER BY rank LIMIT 1`,
		caller.ID, true, prevInstance.Rank).Row()
	if err := row.Scan(&nextRank); err != nil {
		if err == sql.ErrNoRows {
			nextRank = "z"
		} else {
			log.Info().Err(err).Msg("failed to get next channel rank")
			return nil, err
		}
	}

	if prevInstance.Rank == nextRank {
		nextRank += "u"
	}

	log.Info().Str("prev", prevInstance.Rank).Str("next", nextRank).Msg("reordering instance")
	if newRank, ok := lexorank.Rank(prevInstance.Rank, nextRank); ok {
		instanceUser.Rank = newRank
	} else {
		// TODO this might actually happen, need to handle this case
		log.Info().Msg("failed to get instance rank")
		return nil, errors.New("failed to get channel rank")
	}

	if err := db.Save(&instanceUser).Error; err != nil {
		return nil, err
	}

	edge := createUserInstancesEdge(&instanceUser, instanceUser.Instance)
	return edge, nil
}

// PinInstance is the resolver for the pinInstance field.
func (r *mutationResolver) PinInstance(ctx context.Context, instanceID uuid.UUID, input model.InstancePinInput) (*model.UserInstancesEdge, error) {
	caller, err := upsertCaller(ctx)
	if err != nil {
		return nil, err
	}

	db := interfaces.GetDatabase()
	instanceUser := model.InstanceUser{}
	instanceUser.InstanceID = instanceID
	instanceUser.UserID = caller.ID
	if err := db.Preload("Instance").First(&instanceUser, instanceUser).Error; err != nil {
		return nil, err
	}

	instanceUser.Pinned = input.Pinned

	// pinning an instance moves it to the last rank
	if input.Pinned {
		var lastRank string
		row := db.Raw(`
			SELECT rank FROM instance_users
			WHERE user_id = ? AND deleted_at is NULL AND pinned = ?
			ORDER BY rank COLLATE "C" DESC LIMIT 1`,
			caller.ID, true).Row()
		if err := row.Scan(&lastRank); err != nil {
			if err == sql.ErrNoRows {
				lastRank = "a"
			} else {
				log.Info().Err(err).Msg("failed to get next channel rank")
				return nil, err
			}
		}

		if lastRank != instanceUser.Rank {
			lastRank += "u"
		}
		instanceUser.Rank = lastRank
	}

	if err := db.Save(&instanceUser).Error; err != nil {
		return nil, err
	}

	edge := createUserInstancesEdge(&instanceUser, instanceUser.Instance)
	return edge, nil
}

// AddChannel is the resolver for the addChannel field.
func (r *mutationResolver) AddChannel(ctx context.Context, input model.ChannelInput) (*model.InstanceChannelsEdge, error) {
	callerInstanceUser, err := getCallerInstanceUser(ctx, input.InstanceID)
	if err != nil {
		return nil, err
	}

	if err := assertIsModerator(*callerInstanceUser); err != nil {
		return nil, err
	}

	db := interfaces.GetDatabase()

	channel := model.Channel{}
	channel.AuthorID = callerInstanceUser.ID
	channel.Author = callerInstanceUser
	if err := populateChannelFromInput(&channel, input); err != nil {
		return nil, err
	}

	// set the new channels rank
	var rank string
	// TODO use COLLATE "C"
	row := db.Table("channels").Where("instance_id = ? AND deleted_at is NULL", input.InstanceID).Select("coalesce(max(rank), '0')").Row()
	if err := row.Scan(&rank); err != nil {
		if err != sql.ErrNoRows {
			rank = "0"
		} else {
			log.Info().Err(err).Msg("failed to get channel rank")
			return nil, err
		}
	}
	if newRank, ok := lexorank.Rank(rank, ""); ok {
		channel.Rank = newRank
	} else {
		return nil, errors.New("failed to get channel rank")
	}

	if err := assertCanPublish(*callerInstanceUser, channel); err != nil {
		return nil, err
	}
	if err := db.Create(&channel).Error; err != nil {
		return nil, err
	}

	sendChannelNotice(&r.StreamObservers, &channel, model.NoticeKindChannelAdded)

	edge := createInstanceChannelsEdge(&channel)
	return edge, nil
}

// UpdateChannel is the resolver for the updateChannel field.
func (r *mutationResolver) UpdateChannel(ctx context.Context, channelID uuid.UUID, input model.ChannelInput) (*model.InstanceChannelsEdge, error) {
	callerInstanceUser, err := getCallerInstanceUser(ctx, input.InstanceID)
	if err != nil {
		return nil, err
	}

	if err := assertIsModerator(*callerInstanceUser); err != nil {
		return nil, err
	}

	db := interfaces.GetDatabase()
	channel := model.Channel{}
	if err := db.First(&channel, channelID).Error; err != nil {
		return nil, err
	}

	if channel.IsCategory != input.IsCategory {
		return nil, errors.New("cannot change channel type")
	}

	if err := populateChannelFromInput(&channel, input); err != nil {
		return nil, err
	}

	if err := db.Save(&channel).Error; err != nil {
		return nil, err
	}

	sendChannelNotice(&r.StreamObservers, &channel, model.NoticeKindChannelUpdated)

	edge := createInstanceChannelsEdge(&channel)
	return edge, nil
}

// ReorderChannel is the resolver for the reorderChannel field.
func (r *mutationResolver) ReorderChannel(ctx context.Context, channelID uuid.UUID, input model.ChannelReorderInput) (*model.InstanceChannelsEdge, error) {
	db := interfaces.GetDatabase()
	channel := model.Channel{}
	if err := db.First(&channel, channelID).Error; err != nil {
		return nil, err
	}

	prevChannel := model.Channel{}
	if input.PrevChannelID != nil {
		if err := db.First(&prevChannel, input.PrevChannelID).Error; err != nil {
			return nil, err
		}
		if prevChannel.InstanceID != channel.InstanceID {
			return nil, errors.New("prevChannelID must be in the same instance")
		}
	}

	// set the new channels rank
	var nextRank string
	row := db.Raw(`
		SELECT rank FROM channels
		WHERE instance_id = ? AND deleted_at is NULL AND rank > ? COLLATE "C"
		ORDER BY rank LIMIT 1`,
		channel.InstanceID, prevChannel.Rank).Row()
	if err := row.Scan(&nextRank); err != nil {
		if err == sql.ErrNoRows {
			nextRank = "z"
		} else {
			log.Info().Err(err).Msg("failed to get next channel rank")
			return nil, err
		}
	}

	callerInstanceUser, err := getCallerInstanceUser(ctx, channel.InstanceID)
	if err != nil {
		return nil, err
	}

	if err := assertIsModerator(*callerInstanceUser); err != nil {
		return nil, err
	}

	if prevChannel.Rank == nextRank {
		nextRank += "u"
	}
	log.Info().Str("prev", prevChannel.Rank).Str("next", nextRank).Msg("reordering channel")
	if newRank, ok := lexorank.Rank(prevChannel.Rank, nextRank); ok {
		channel.Rank = newRank
	} else {
		// TODO this might actually happen, need to handle this case
		log.Info().Msg("failed to get channel rank")
		return nil, errors.New("failed to get channel rank")
	}

	if err := db.Save(&channel).Error; err != nil {
		return nil, err
	}

	sendChannelNotice(&r.StreamObservers, &channel, model.NoticeKindChannelUpdated)

	edge := createInstanceChannelsEdge(&channel)
	return edge, nil
}

// RemoveChannel is the resolver for the removeChannel field.
func (r *mutationResolver) RemoveChannel(ctx context.Context, channelID uuid.UUID) (*model.InstanceChannelsEdge, error) {
	db := interfaces.GetDatabase()

	channel := model.Channel{}
	if err := db.First(&channel, channelID).Error; err != nil {
		return nil, err
	}

	callerInstanceUser, err := getCallerInstanceUser(ctx, channel.InstanceID)
	if err != nil {
		return nil, err
	}

	if err := assertIsModerator(*callerInstanceUser); err != nil {
		return nil, err
	}

	db.Delete(&channel, channelID)

	sendChannelNotice(&r.StreamObservers, &channel, model.NoticeKindChannelRemoved)

	edge := createInstanceChannelsEdge(&channel)
	return edge, nil
}

// AddMessage is the resolver for the addMessage field.
func (r *mutationResolver) AddMessage(ctx context.Context, input model.MessageInput) (*model.ChannelMessagesEdge, error) {
	db := interfaces.GetDatabase()
	channel := model.Channel{}
	if err := db.First(&channel, input.ChannelID).Error; err != nil {
		return nil, err
	}

	callerInstanceUser, err := getCallerInstanceUser(ctx, channel.InstanceID)
	if err != nil {
		return nil, err
	}

	if channel.IsCategory {
		return nil, errors.New("You can't publish to a category")
	}
	if err := assertCanPublish(*callerInstanceUser, channel); err != nil {
		return nil, err
	}
	if r.ProfanityDetector.IsProfane(input.Text) {
		return nil, errors.New("Message contains contains language that is not allowed.")
	}

	message := model.Message{}
	copier.Copy(&message, input)
	message.RepliedMessageID = input.RepliedMessageID
	message.AuthorID = callerInstanceUser.ID
	message.Author = callerInstanceUser

	db.Model(&channel).Association("Messages").Append(&message)

	sendMessageNotice(&r.StreamObservers, &message, &channel, model.NoticeKindMessageAdded)

	edge := createChannelMessagesEdge(&message)

	channel.LastMessageAddedAt = &message.CreatedAt
	channel.MessageCount++
	if err := db.Save(&channel).Error; err != nil {
		return nil, err
	}

	if channel.IsComments {
		instance := model.Instance{}
		if err := db.Find(&instance, channel.InstanceID).Error; err != nil {
			return nil, err
		}

		instanceAuthor := model.InstanceUser{}
		if err := db.Find(&instanceAuthor, instance.AuthorID).Error; err != nil {
			return nil, err
		}

		instance.CommentsCount = channel.MessageCount
		if err := db.Save(&instance).Error; err != nil {
			return nil, err
		}

		if instanceAuthor.UserID != callerInstanceUser.UserID {
			notification, err := createNotificationCommentAdded(instanceAuthor.UserID, &message)
			if err != nil {
				return nil, err
			}
			sendUserNotificationNotice(&r.StreamObservers, notification)
		}
	}

	if message.RepliedMessageID != nil {
		repliedMessage := model.Message{}
		if err := db.Preload("Author").First(&repliedMessage, message.RepliedMessageID).Error; err != nil {
			return nil, err
		}

		if repliedMessage.AuthorID != callerInstanceUser.ID {
			notification, err := createNotificationReplyAdded(&repliedMessage, &message)
			if err != nil {
				return nil, err
			}
			sendUserNotificationNotice(&r.StreamObservers, notification)
		}
	}

	return edge, nil
}

// RemoveMessage is the resolver for the removeMessage field.
func (r *mutationResolver) RemoveMessage(ctx context.Context, messageID uuid.UUID) (*model.ChannelMessagesEdge, error) {
	db := interfaces.GetDatabase()

	message := model.Message{}
	if err := db.Preload("Author").First(&message, messageID).Error; err != nil {
		return nil, err
	}

	channel := model.Channel{}
	if err := db.First(&channel, message.ChannelID).Error; err != nil {
		return nil, err
	}

	callerInstanceUser, err := getCallerInstanceUser(ctx, channel.InstanceID)
	if err != nil {
		return nil, err
	}

	if err := assertCanPublish(*callerInstanceUser, channel); err != nil {
		return nil, err
	}

	if message.AuthorID != callerInstanceUser.ID {
		if err := assertIsModerator(*callerInstanceUser); err != nil {
			return nil, err
		}
	}

	db.Delete(&message)

	channel.MessageCount--
	if err := db.Save(&channel).Error; err != nil {
		return nil, err
	}

	if err := db.Delete(&model.Notification{}, "message_id = ?", messageID).Error; err != nil {
		return nil, err
	}

	if err := db.Delete(&model.Notification{}, "reply_id = ?", messageID).Error; err != nil {
		return nil, err
	}

	sendMessageNotice(&r.StreamObservers, &message, &channel, model.NoticeKindMessageRemoved)

	edge := createChannelMessagesEdge(&message)
	return edge, nil
}

// AddRole is the resolver for the AddRole field.
func (r *mutationResolver) AddRole(ctx context.Context, authorID uuid.UUID, role model.Role, banReason *string) (*model.Author, error) {
	db := interfaces.GetDatabase()
	instanceUser := model.InstanceUser{}
	if err := db.Find(&instanceUser, authorID).Error; err != nil {
		return nil, err
	}

	callerInstanceUser, err := getCallerInstanceUser(ctx, instanceUser.InstanceID)
	if err != nil {
		return nil, err
	}

	if contains(instanceUser.Roles, role.String()) {
		return nil, fmt.Errorf("user already has role %s", role)
	}

	if role == model.RoleModerator {
		if err := assertIsAdmin(*callerInstanceUser); err != nil {
			return nil, err
		}
		if err := assertIsNotBanned(instanceUser); err != nil {
			return nil, err
		}
	} else if role == model.RoleBanned {
		if err := assertIsModerator(*callerInstanceUser); err != nil {
			return nil, err
		}
		if err := assertIsNotAdmin(instanceUser); err != nil {
			return nil, err
		}

		// // TODO Make this more efficient
		// messages := []model.Message{}
		// if db.Where("author_id = ?", authorID).Preload("Channel").Find(&messages); err != nil {
		// 	return nil, err
		// }
		// for _, message := range messages {
		// 	sendMessageNotification(r.StreamObservers, &message, message.Channel, model.InstanceMutationTypeMessageRemoved)
		// }
		// if err := db.Where("author_id = ?", authorID).Delete(&model.Message{}).Error; err != nil {
		// 	return nil, err
		// }

	} else if role == model.RoleMember {
		if err := assertIsModerator(*callerInstanceUser); err != nil {
			return nil, err
		}
		if err := assertIsNotBanned(instanceUser); err != nil {
			return nil, err
		}
	} else {
		return nil, fmt.Errorf("role %s is not allowed to be added", role)
	}

	instanceUser.Roles = append(instanceUser.Roles, role.String())

	if banReason != nil {
		instanceUser.BanReason = banReason
	}

	// if adding moderator, make sure they are also a member
	if role == model.RoleModerator && !contains(instanceUser.Roles, model.RoleMember.String()) {
		instanceUser.Roles = append(instanceUser.Roles, model.RoleMember.String())
	}

	// record the time they were banned
	if role == model.RoleBanned {
		now := time.Now()
		instanceUser.BannedAt = &now
	}

	if err := db.Save(&instanceUser).Error; err != nil {
		return nil, err
	}

	refreshInstanceStreamRoles(&r.StreamObservers, &instanceUser)

	author := instanceUserToAuthor(&instanceUser)
	sendAuthorNotice(&r.StreamObservers, author, model.NoticeKindAuthorUpdated)

	client := interfaces.GetPubSubClient()
	authorFragment := pixellandchat.AuthorFragment{}
	copier.Copy(&authorFragment, author)
	client.PublishAuthorEvent(ctx, model.NoticeKindAuthorUpdated, authorFragment)
	return author, nil
}

// RemoveRole is the resolver for the RemoveRole field.
func (r *mutationResolver) RemoveRole(ctx context.Context, authorID uuid.UUID, role model.Role) (*model.Author, error) {
	db := interfaces.GetDatabase()
	instanceUser := model.InstanceUser{}
	if err := db.Find(&instanceUser, authorID).Error; err != nil {
		return nil, err
	}

	callerInstanceUser, err := getCallerInstanceUser(ctx, instanceUser.InstanceID)
	if err != nil {
		return nil, err
	}

	if !contains(instanceUser.Roles, role.String()) {
		return nil, fmt.Errorf("user does not have role %s", role)
	}

	if role == model.RoleModerator {
		if err := assertIsAdmin(*callerInstanceUser); err != nil {
			return nil, err
		}
	} else if role == model.RoleBanned || role == model.RoleMember {
		if err := assertIsModerator(*callerInstanceUser); err != nil {
			return nil, err
		}
	} else {
		return nil, fmt.Errorf("role %s is not allowed to be removed", role)
	}

	instanceUser.Roles = RemoveFromSlice(instanceUser.Roles, role.String())

	if err := db.Save(&instanceUser).Error; err != nil {
		return nil, err
	}

	refreshInstanceStreamRoles(&r.StreamObservers, &instanceUser)

	author := instanceUserToAuthor(&instanceUser)
	sendAuthorNotice(&r.StreamObservers, author, model.NoticeKindAuthorUpdated)

	client := interfaces.GetPubSubClient()
	authorFragment := pixellandchat.AuthorFragment{}
	copier.Copy(&authorFragment, author)
	client.PublishAuthorEvent(ctx, model.NoticeKindAuthorUpdated, authorFragment)

	return author, nil
}

// AddInvite is the resolver for the addInvite field.
func (r *mutationResolver) AddInvite(ctx context.Context, input model.InviteInput) (*model.Invite, error) {
	db := interfaces.GetDatabase()

	callerInstanceUser, err := getCallerInstanceUser(ctx, input.InstanceID)
	if err != nil {
		return nil, err
	}

	if err := assertIsModerator(*callerInstanceUser); err != nil {
		return nil, err
	}

	invite := model.Invite{}
	invite.InstanceID = input.InstanceID
	invite.AuthorID = callerInstanceUser.ID
	invite.Author = callerInstanceUser
	if input.ExpiresAt != nil {
		invite.ExpiresAt = input.ExpiresAt
	}
	if input.Redemptions != nil {
		invite.Redemptions = input.Redemptions
	}
	invite.Code = generateInviteCode()

	invite.Instance = &model.Instance{}
	if err := db.First(invite.Instance, invite.InstanceID).Error; err != nil {
		return nil, err
	}

	if err := db.Create(&invite).Error; err != nil {
		return nil, err
	}

	return &invite, nil
}

// RemoveInvite is the resolver for the removeInvite field.
func (r *mutationResolver) RemoveInvite(ctx context.Context, inviteID uuid.UUID) (*model.Invite, error) {
	db := interfaces.GetDatabase()

	invite := model.Invite{}
	if err := db.Preload("instance").Preload("Author").First(&invite, inviteID).Error; err != nil {
		return nil, err
	}

	callerInstanceUser, err := getCallerInstanceUser(ctx, invite.InstanceID)
	if err != nil {
		return nil, err
	}

	if err := assertIsModerator(*callerInstanceUser); err != nil {
		return nil, err
	}

	db.Delete(&invite)

	return &invite, nil
}

// RedeemInvite is the resolver for the redeemInvite field.
func (r *mutationResolver) RedeemInvite(ctx context.Context, code string) (*model.Invite, error) {
	db := interfaces.GetDatabase()

	invite := model.Invite{}
	if err := db.Where("code = ?", code).Preload("Instance").Preload("Author").First(&invite).Error; err != nil {
		return nil, err
	}

	if invite.ExpiresAt != nil && invite.ExpiresAt.Before(time.Now()) {
		return nil, errors.New("invite expired")
	}

	if invite.Redemptions != nil && *invite.Redemptions <= 0 {
		return nil, errors.New("invite has no redemptions left")
	}

	if err := assertIsModerator(*invite.Author); err != nil {
		return nil, errors.New("invite author is no longer a moderator")
	}

	callerInstanceUser, err := getCallerInstanceUser(ctx, invite.InstanceID)
	if err != nil {
		return nil, err
	}

	if contains(callerInstanceUser.Roles, model.RoleMember.String()) {
		return nil, errors.New("caller is already a member")
	}

	callerInstanceUser.Roles = append(callerInstanceUser.Roles, model.RoleMember.String())
	if invite.Redemptions != nil {
		*invite.Redemptions--
	}

	if err := db.Transaction(func(tx *gorm.DB) error {
		if err := tx.Save(&callerInstanceUser).Error; err != nil {
			return err
		}

		if err := db.Save(&invite).Error; err != nil {
			return err
		}

		return nil
	}); err != nil {
		return nil, err
	}

	refreshInstanceStreamRoles(&r.StreamObservers, callerInstanceUser)

	author := instanceUserToAuthor(callerInstanceUser)
	sendAuthorNotice(&r.StreamObservers, author, model.NoticeKindAuthorUpdated)

	client := interfaces.GetPubSubClient()
	authorFragment := pixellandchat.AuthorFragment{}
	copier.Copy(&authorFragment, author)
	go client.PublishAuthorEvent(ctx, model.NoticeKindAuthorUpdated, authorFragment)

	return &invite, nil
}

// AddLike is the resolver for the addLike field.
func (r *mutationResolver) AddLike(ctx context.Context, instanceID uuid.UUID) (*model.InstanceLikesEdge, error) {
	// TODO consider using transaction here

	db := interfaces.GetDatabase()

	callerInstanceUser, err := getCallerInstanceUser(ctx, instanceID)
	if err != nil {
		return nil, err
	}

	if callerInstanceUser.LikedByMe {
		return nil, errors.New("user already likes instance")
	}

	callerInstanceUser.LikedByMe = true
	now := time.Now()
	callerInstanceUser.LikedAt = &now
	if err := db.Save(&callerInstanceUser).Error; err != nil {
		return nil, err
	}

	instance := model.Instance{}
	if err := db.First(&instance, instanceID).Error; err != nil {
		return nil, err
	}
	instance.LikesCount += 1
	if err := db.Save(&instance).Error; err != nil {
		return nil, err
	}

	instanceAuthor := model.InstanceUser{}
	if err := db.Find(&instanceAuthor, instance.AuthorID).Error; err != nil {
		return nil, err
	}

	edge := createInstanceLikesEdge(callerInstanceUser)

	if instanceAuthor.UserID != callerInstanceUser.UserID {
		notification, err := createNotificationLikeAdded(instanceAuthor.UserID, callerInstanceUser)
		if err != nil {
			return nil, err
		}
		sendUserNotificationNotice(&r.StreamObservers, notification)
	}

	sendLikeNotice(&r.StreamObservers, edge, model.NoticeKindLikeAdded)

	return edge, nil
}

// RemoveLike is the resolver for the removeLike field.
func (r *mutationResolver) RemoveLike(ctx context.Context, instanceID uuid.UUID) (*model.InstanceLikesEdge, error) {
	// TODO consider using transaction here
	db := interfaces.GetDatabase()

	callerInstanceUser, err := getCallerInstanceUser(ctx, instanceID)
	if err != nil {
		return nil, err
	}

	if !callerInstanceUser.LikedByMe {
		return nil, errors.New("user doesn't already like instance")
	}

	callerInstanceUser.LikedByMe = false
	if err := db.Save(&callerInstanceUser).Error; err != nil {
		return nil, err
	}

	instance := model.Instance{}
	if err := db.First(&instance, instanceID).Error; err != nil {
		return nil, err
	}
	instance.LikesCount -= 1
	if err := db.Save(&instance).Error; err != nil {
		return nil, err
	}

	edge := createInstanceLikesEdge(callerInstanceUser)

	sendLikeNotice(&r.StreamObservers, edge, model.NoticeKindLikeRemoved)

	return edge, nil
}

// AddBadge is the resolver for the addBadge field.
func (r *mutationResolver) AddBadge(ctx context.Context, input model.BadgeInput) (*model.Badge, error) {
	db := interfaces.GetDatabase()

	badge := model.Badge{}
	copier.Copy(&badge, input)

	if err := db.Save(&badge).Error; err != nil {
		return nil, err
	}

	return &badge, nil
}

// AssignBadge is the resolver for the assignBadge field.
func (r *mutationResolver) AssignBadge(ctx context.Context, userID uuid.UUID, badgeID uuid.UUID) (*model.Badge, error) {
	db := interfaces.GetDatabase()

	user := model.User{}
	if err := db.Find(&user, userID).Error; err != nil {
		return nil, err
	}

	badge := model.Badge{}
	if err := db.Find(&badge, badgeID).Error; err != nil {
		return nil, err
	}

	userBadge := model.UserBadge{}
	if err := db.Model(userBadge).Where("user_id = ? AND badge_id = ?", userID, badgeID).First(&userBadge).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			// assign new badge to user
			if err := db.Model(&user).Association("Badges").Append(&badge); err != nil {
				log.Error().Err(err).Msg("failed to assign badge")
				return nil, err
			}
		} else {
			return nil, err
		}
	} else {
		// increment badge count
		userBadge.Count++
		if err := db.Save(&userBadge).Error; err != nil {
			return nil, err
		}
	}

	notification, err := createNotificationBadgeAdded(userID, &badge)
	if err != nil {
		return nil, err
	}
	sendUserNotificationNotice(&r.StreamObservers, notification)

	return &badge, nil
}

// UnassignBadge is the resolver for the unassignBadge field.
func (r *mutationResolver) UnassignBadge(ctx context.Context, userID uuid.UUID, badgeID uuid.UUID) (*model.Badge, error) {
	db := interfaces.GetDatabase()

	user := model.User{}
	if err := db.Find(&user, userID).Error; err != nil {
		return nil, err
	}

	badge := model.Badge{}
	if err := db.Find(&badge, badgeID).Error; err != nil {
		return nil, err
	}

	userBadge := model.UserBadge{}
	if err := db.Model(userBadge).Where("user_id = ? AND badge_id = ?", userID, badgeID).First(&userBadge).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, errors.New("user does not have badge")
		}
	}

	if userBadge.Count > 1 {
		userBadge.Count--
		if err := db.Save(&userBadge).Error; err != nil {
			return nil, err
		}
	} else {
		if err := db.Model(&user).Association("Badges").Delete(&badge); err != nil {
			return nil, err
		}
	}

	return &badge, nil
}

// UpdateBadge is the resolver for the updateBadge field.
func (r *mutationResolver) UpdateBadge(ctx context.Context, badgeID uuid.UUID, input model.BadgeInput) (*model.Badge, error) {
	db := interfaces.GetDatabase()

	badge := model.Badge{}
	if err := db.Find(&badge, badgeID).Error; err != nil {
		return nil, err
	}

	copier.Copy(&badge, input)

	if err := db.Save(&badge).Error; err != nil {
		return nil, err
	}

	return &badge, nil
}

// RemoveBadge is the resolver for the removeBadge field.
func (r *mutationResolver) RemoveBadge(ctx context.Context, badgeID uuid.UUID) (*model.Badge, error) {
	db := interfaces.GetDatabase()

	badge := model.Badge{}
	if err := db.First(&badge, badgeID).Error; err != nil {
		return nil, err
	}

	if err := db.Delete(&badge).Error; err != nil {
		return nil, err
	}

	return &badge, nil
}

// Kind is the resolver for the kind field.
func (r *notificationResolver) Kind(ctx context.Context, obj *model.Notification) (model.NotificationKind, error) {
	return model.NotificationKind(obj.Kind), nil
}

// Author is the resolver for the author field.
func (r *notificationResolver) Author(ctx context.Context, obj *model.Notification) (*model.Author, error) {
	instanceUser := model.InstanceUser{}
	if obj.AuthorID == nil {
		return nil, nil
	}

	if obj.Author == nil {
		db := interfaces.GetDatabase()
		if err := db.First(&instanceUser, obj.AuthorID).Error; err != nil {
			return nil, err
		}
	} else {
		instanceUser = *obj.Author
	}

	return instanceUserToAuthor(&instanceUser), nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context) (*model.User, error) {
	db := interfaces.GetDatabase()
	user := model.User{}

	parsed := parseContext(ctx)
	if parsed.Uid == "" {
		return nil, errors.New("uid not found in context")
	}

	if err := db.FirstOrCreate(&user, "uid = ?", parsed.Uid).Error; err != nil {
		return nil, err
	}

	return &user, nil
}

// Instance is the resolver for the instance field.
func (r *queryResolver) Instance(ctx context.Context, id uuid.UUID) (*model.UserInstancesEdge, error) {
	instanceUser, err := getCallerInstanceUser(ctx, id)
	if err != nil {
		return nil, err
	}

	edge := createUserInstancesEdge(instanceUser, instanceUser.Instance)
	return edge, nil
}

// Channel is the resolver for the channel field.
func (r *queryResolver) Channel(ctx context.Context, id uuid.UUID) (*model.Channel, error) {
	db := interfaces.GetDatabase()
	channel := model.Channel{}
	if err := db.First(&channel, id).Error; err != nil {
		return nil, err
	}

	callerInstanceUser, err := getCallerInstanceUser(ctx, channel.InstanceID)
	if err != nil {
		return nil, err
	}

	if err := assertCanRead(*callerInstanceUser, channel); err != nil {
		return nil, err
	}

	return &channel, nil
}

// Invite is the resolver for the invite field.
func (r *queryResolver) Invite(ctx context.Context, instanceID uuid.UUID) (*model.Invite, error) {
	callerInstanceUser, err := getCallerInstanceUser(ctx, instanceID)
	if err != nil {
		return nil, err
	}

	if err := assertIsModerator(*callerInstanceUser); err != nil {
		return nil, err
	}

	db := interfaces.GetDatabase()
	invite := model.Invite{}

	instance := model.Instance{}
	if err := db.First(&instance, instanceID).Error; err != nil {
		return nil, err
	}

	if err := db.Model(invite).
		Order("created_at desc").
		Where("instance_id = ?", instanceID).
		Where("expires_at > ? OR expires_at is NULL", time.Now()).
		Where("redemptions > ? OR redemptions is NULL", 0).
		Where("author_id = ?", callerInstanceUser.ID).
		Preload("Author").
		First(&invite).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			invite.InstanceID = instanceID
			invite.AuthorID = callerInstanceUser.ID
			invite.Author = callerInstanceUser
			invite.Code = generateInviteCode()
			if err := db.Create(&invite).Error; err != nil {
				return nil, err
			}
		} else {
			return nil, err
		}
	}

	invite.Instance = &instance

	return &invite, nil
}

// CheckInvite is the resolver for the checkInvite field.
func (r *queryResolver) CheckInvite(ctx context.Context, code string) (*model.Invite, error) {
	db := interfaces.GetDatabase()
	invite := model.Invite{
		Code: code,
	}

	if err := db.Preload("Instance").Preload("Author").First(&invite, invite).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, errors.New("invite not found")
		} else {
			return nil, err
		}
	}

	if invite.ExpiresAt != nil && invite.ExpiresAt.Before(time.Now()) {
		return nil, errors.New("invite has expired")
	}

	if invite.Redemptions != nil && *invite.Redemptions <= 0 {
		return nil, errors.New("invite has no redemptions left")
	}

	log.Info().Msgf("invite: %+v", invite)

	callerInstanceUser, err := getCallerInstanceUser(ctx, invite.InstanceID)
	if err != nil {
		return nil, err
	}
	if contains(callerInstanceUser.Roles, model.RoleMember.String()) {
		return nil, errors.New("cannot redeem invite, you are already a member")
	}

	return &invite, nil
}

// Author is the resolver for the author field.
func (r *queryResolver) Author(ctx context.Context, id uuid.UUID) (*model.Author, error) {
	db := interfaces.GetDatabase()
	instanceUser := model.InstanceUser{}
	if err := db.First(&instanceUser, id).Error; err != nil {
		return nil, err
	}

	return instanceUserToAuthor(&instanceUser), nil
}

// UserBadges is the resolver for the userBadges field.
func (r *queryResolver) UserBadges(ctx context.Context, userID uuid.UUID, first int, after string) (*model.UserBadgesConnection, error) {
	if first == 0 {
		return &model.UserBadgesConnection{
			Edges: make([]*model.UserBadgesEdge, 0),
			PageInfo: &model.PageInfo{
				HasNextPage:     false,
				HasPreviousPage: false,
			},
		}, nil
	}

	db := interfaces.GetDatabase()
	userBadges := []model.UserBadge{}

	user := model.User{}
	if err := db.First(&user, userID).Error; err != nil {
		return nil, err
	}

	tx := db.Model(model.UserBadge{}).Preload("Badge").Limit(first+1).Order("created_at asc").Where("user_id = ?", userID)

	if after != "" {
		createdAt, err := fromCursorHash(after)
		if err != nil {
			return nil, err
		}
		tx = tx.Where("created_at < ?", createdAt)
	}

	tx.Find(&userBadges)

	hasPreviousPage := (len(userBadges) == first+1)
	if len(userBadges) > 0 && hasPreviousPage {
		userBadges = userBadges[:len(userBadges)-1]
	}

	log.Info().Msgf("userBadges: %+v", userBadges)
	log.Info().Msgf("count: %d", len(userBadges))

	edges := []*model.UserBadgesEdge{}
	for i := len(userBadges) - 1; i >= 0; i-- {
		edge := createUserBadgesEdge(&userBadges[i])
		edges = append(edges, edge)
	}

	return &model.UserBadgesConnection{
		Edges: edges,
		PageInfo: &model.PageInfo{
			HasPreviousPage: hasPreviousPage,
			HasNextPage:     false, // TODO
		},
	}, nil
}

// Badges is the resolver for the badges field.
func (r *queryResolver) Badges(ctx context.Context, first int, after string) (*model.AppBadgesConnection, error) {
	db := interfaces.GetDatabase()
	badges := []model.Badge{}

	tx := db.Model(&model.Badge{}).Limit(first + 1).Order("created_at desc")

	if after != "" {
		createdAt, err := fromCursorHash(after)
		if err != nil {
			return nil, err
		}
		tx = tx.Where("created_at < ?", createdAt)
	}

	tx.Find(&badges)

	hasNextPage := (len(badges) == first+1)
	if len(badges) > 0 && hasNextPage {
		badges = badges[:len(badges)-1]
	}

	edges := []*model.AppBadgesEdge{}
	for i := 0; i < len(badges); i++ {
		edge := createAppBadgesEdge(&badges[i])
		edges = append(edges, edge)
	}

	return &model.AppBadgesConnection{
		Edges: edges,
		PageInfo: &model.PageInfo{
			HasPreviousPage: false, // TODO
			HasNextPage:     hasNextPage,
		},
	}, nil
}

// InstanceUserListByIds is the resolver for the instanceUserListByIds field.
func (r *queryResolver) InstanceUserListByIds(ctx context.Context, instanceID uuid.UUID, instanceUserIds []uuid.UUID) ([]*model.Author, error) {
	db := interfaces.GetDatabase()
	instanceUsers := []model.InstanceUser{}

	if err := db.Where("instance_id = ? AND id IN (?)", instanceID, instanceUserIds).Find(&instanceUsers).Error; err != nil {
		return nil, err
	}

	authors := []*model.Author{}
	for _, instanceUser := range instanceUsers {
		authors = append(authors, instanceUserToAuthor(&instanceUser))
	}

	return authors, nil
}

// Stream is the resolver for the stream field.
func (r *subscriptionResolver) Stream(ctx context.Context, instanceID uuid.UUID) (<-chan *model.Notice, error) {
	callerInstanceUser, err := getCallerInstanceUser(ctx, instanceID)
	if err != nil {
		return nil, err
	}

	stream := make(chan *model.Notice, 1)
	listenerId := uuid.New().String()
	go func() {
		<-ctx.Done()
		r.StreamObservers.Delete(listenerId)
	}()

	roles := append(callerInstanceUser.Roles, model.RoleAllUsers.String())
	r.StreamObservers.Store(listenerId, &StreamObserver{
		UserId:     callerInstanceUser.UserID,
		InstanceId: instanceID,
		Roles:      roles,
		Stream:     stream,
	})

	return stream, nil
}

// InstancesConnection is the resolver for the instancesConnection field.
func (r *userResolver) InstancesConnection(ctx context.Context, obj *model.User, first int, after string) (*model.UserInstancesConnection, error) {
	if first == 0 {
		return &model.UserInstancesConnection{
			Edges: make([]*model.UserInstancesEdge, 0),
			PageInfo: &model.PageInfo{
				HasNextPage:     false,
				HasPreviousPage: false,
			},
		}, nil
	}

	db := interfaces.GetDatabase()
	instanceUsers := []*model.InstanceUser{}

	tx := db.
		Joins("INNER JOIN instances ON instances.id = instance_users.instance_id").
		Where("instances.deleted_at is null").
		Preload("Instance").Limit(first + 1).
		Order("created_at asc")

	if after != "" {
		created_at, err := fromCursorHash(after)
		if err != nil {
			return nil, err
		}
		tx = tx.Where("created_at < ?", created_at)
	}

	if err := tx.Find(&instanceUsers, &model.InstanceUser{UserID: obj.ID, Pinned: true}).Error; err != nil {
		return nil, err
	}
	log.Info().Msgf("instanceUsers: %+v", instanceUsers)

	hasNextPage := (len(instanceUsers) == first+1)
	if len(instanceUsers) > 0 && hasNextPage {
		instanceUsers = instanceUsers[:len(instanceUsers)-1]
	}

	edges := []*model.UserInstancesEdge{}
	for i := 0; i < len(instanceUsers); i++ {
		edge := createUserInstancesEdge(instanceUsers[i], instanceUsers[i].Instance)
		edges = append(edges, edge)
	}

	return &model.UserInstancesConnection{
		Edges: edges,
		PageInfo: &model.PageInfo{
			HasNextPage:     hasNextPage,
			HasPreviousPage: false, // TODO
		},
	}, nil
}

// NotificationsConnection is the resolver for the notificationsConnection field.
func (r *userResolver) NotificationsConnection(ctx context.Context, obj *model.User, last int, before string) (*model.UserNotificationsConnection, error) {
	caller, err := upsertCaller(ctx)
	if err != nil {
		return nil, err
	}

	db := interfaces.GetDatabase()
	unreadNotification := model.Notification{}
	if err := db.Where("user_id = ? AND created_at > ? AND deleted_at is null", caller.ID, caller.ReadNotificationsAt).Find(&unreadNotification).Error; err != nil {
		return nil, err
	}
	hasUnread := unreadNotification.ID != uuid.Nil

	if last == 0 {
		return &model.UserNotificationsConnection{
			Edges: make([]*model.UserNotificationsEdge, 0),
			PageInfo: &model.PageInfo{
				HasNextPage:     false,
				HasPreviousPage: false,
			},
			HasUnread: hasUnread,
		}, nil
	}

	notifications := []model.Notification{}

	tx := db.Model(&model.Notification{}).Where("user_id = ?", obj.ID).Limit(last + 1).Order("created_at desc")

	if before != "" {
		createdAt, err := fromCursorHash(before)
		if err != nil {
			return nil, err
		}
		tx = tx.Where("created_at < ?", createdAt)
	}

	tx.Preload("Author").Preload("Instance").Preload("Message").Preload("Reply").Preload("Badge").Find(&notifications)

	hasPreviousPage := (len(notifications) == last+1)
	if len(notifications) > 0 && hasPreviousPage {
		notifications = notifications[:len(notifications)-1]
	}

	edges := []*model.UserNotificationsEdge{}
	for i := 0; i < len(notifications); i++ {
		edge := createUserNotificationsEdge(&notifications[i])
		edges = append(edges, edge)
	}

	if before == "" {
		now := time.Now()
		caller.ReadNotificationsAt = &now
		if err := db.Save(&caller).Error; err != nil {
			return nil, err
		}
	}

	return &model.UserNotificationsConnection{
		Edges: edges,
		PageInfo: &model.PageInfo{
			HasPreviousPage: hasPreviousPage,
			HasNextPage:     false, // TODO
		},
		HasUnread: hasUnread,
	}, nil
}

// Channel returns generated.ChannelResolver implementation.
func (r *Resolver) Channel() generated.ChannelResolver { return &channelResolver{r} }

// Instance returns generated.InstanceResolver implementation.
func (r *Resolver) Instance() generated.InstanceResolver { return &instanceResolver{r} }

// Invite returns generated.InviteResolver implementation.
func (r *Resolver) Invite() generated.InviteResolver { return &inviteResolver{r} }

// Message returns generated.MessageResolver implementation.
func (r *Resolver) Message() generated.MessageResolver { return &messageResolver{r} }

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Notification returns generated.NotificationResolver implementation.
func (r *Resolver) Notification() generated.NotificationResolver { return &notificationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// Subscription returns generated.SubscriptionResolver implementation.
func (r *Resolver) Subscription() generated.SubscriptionResolver { return &subscriptionResolver{r} }

// User returns generated.UserResolver implementation.
func (r *Resolver) User() generated.UserResolver { return &userResolver{r} }

type channelResolver struct{ *Resolver }
type instanceResolver struct{ *Resolver }
type inviteResolver struct{ *Resolver }
type messageResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type notificationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
